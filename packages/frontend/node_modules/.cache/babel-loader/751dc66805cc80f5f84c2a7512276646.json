{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Hotkey, Hotkeys, HotkeysTarget, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport { Column } from \"./column\";\nimport * as Classes from \"./common/classes\";\nimport { Clipboard } from \"./common/clipboard\";\nimport { columnInteractionBarContextTypes } from \"./common/context\";\nimport { Direction } from \"./common/direction\";\nimport * as Errors from \"./common/errors\";\nimport { Grid } from \"./common/grid\";\nimport * as FocusedCellUtils from \"./common/internal/focusedCellUtils\";\nimport * as ScrollUtils from \"./common/internal/scrollUtils\";\nimport * as SelectionUtils from \"./common/internal/selectionUtils\";\nimport { Rect } from \"./common/rect\";\nimport { RenderMode } from \"./common/renderMode\";\nimport { Utils } from \"./common/utils\";\nimport { ColumnHeader } from \"./headers/columnHeader\";\nimport { ColumnHeaderCell } from \"./headers/columnHeaderCell\";\nimport { renderDefaultRowHeader, RowHeader } from \"./headers/rowHeader\";\nimport { ResizeSensor } from \"./interactions/resizeSensor\";\nimport { GuideLayer } from \"./layers/guides\";\nimport { RegionLayer } from \"./layers/regions\";\nimport { Locator } from \"./locator\";\nimport { QuadrantType } from \"./quadrants/tableQuadrant\";\nimport { TableQuadrantStack } from \"./quadrants/tableQuadrantStack\";\nimport { ColumnLoadingOption, RegionCardinality, Regions, SelectionModes, TableLoadingOption } from \"./regions\";\nimport { TableBody } from \"./tableBody\"; // HACKHACK(adahiya): fix for Blueprint 4.0\n// eslint-disable-next-line deprecation/deprecation\n\nvar Table =\n/** @class */\nfunction (_super) {\n  __extends(Table, _super);\n\n  function Table(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.refHandlers = {\n      cellContainer: function (ref) {\n        return _this.cellContainerElement = ref;\n      },\n      columnHeader: function (ref) {\n        return _this.columnHeaderElement = ref;\n      },\n      quadrantStack: function (ref) {\n        return _this.quadrantStackInstance = ref;\n      },\n      rootTable: function (ref) {\n        return _this.rootTableElement = ref;\n      },\n      rowHeader: function (ref) {\n        return _this.rowHeaderElement = ref;\n      },\n      scrollContainer: function (ref) {\n        return _this.scrollContainerElement = ref;\n      }\n    };\n    /*\n     * This value is set to `true` when all cells finish mounting for the first\n     * time. It serves as a signal that we can switch to batch rendering.\n     */\n\n    _this.didCompletelyMount = false; // Selection resize\n    // ----------------\n\n    _this.handleSelectionResizeUp = function (e) {\n      return _this.handleSelectionResize(e, Direction.UP);\n    };\n\n    _this.handleSelectionResizeDown = function (e) {\n      return _this.handleSelectionResize(e, Direction.DOWN);\n    };\n\n    _this.handleSelectionResizeLeft = function (e) {\n      return _this.handleSelectionResize(e, Direction.LEFT);\n    };\n\n    _this.handleSelectionResizeRight = function (e) {\n      return _this.handleSelectionResize(e, Direction.RIGHT);\n    };\n\n    _this.handleSelectionResize = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n\n      if (selectedRegions.length === 0) {\n        return;\n      }\n\n      var index = FocusedCellUtils.getFocusedOrLastSelectedIndex(selectedRegions, focusedCell);\n      var region = selectedRegions[index];\n      var nextRegion = SelectionUtils.resizeRegion(region, direction, focusedCell);\n\n      _this.updateSelectedRegionAtIndex(nextRegion, index);\n    };\n\n    _this.handleCopy = function (e) {\n      var _a = _this.props,\n          getCellClipboardData = _a.getCellClipboardData,\n          onCopy = _a.onCopy;\n      var selectedRegions = _this.state.selectedRegions;\n\n      if (getCellClipboardData == null) {\n        return;\n      } // prevent \"real\" copy from being called\n\n\n      e.preventDefault();\n      e.stopPropagation();\n      var cells = Regions.enumerateUniqueCells(selectedRegions, _this.grid.numRows, _this.grid.numCols);\n      var sparse = Regions.sparseMapCells(cells, getCellClipboardData);\n\n      if (sparse != null) {\n        var success = Clipboard.copyCells(sparse);\n        onCopy === null || onCopy === void 0 ? void 0 : onCopy(success);\n      }\n    };\n\n    _this.renderMenu = function (refHandler) {\n      var _a;\n\n      var classes = classNames(Classes.TABLE_MENU, (_a = {}, _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_TABLE), _a));\n      return React.createElement(\"div\", {\n        className: classes,\n        ref: refHandler,\n        onMouseDown: _this.handleMenuMouseDown\n      }, _this.maybeRenderRegions(_this.styleMenuRegion));\n    };\n\n    _this.handleMenuMouseDown = function (e) {\n      // the shift+click interaction expands the region from the focused cell.\n      // thus, if shift is pressed we shouldn't move the focused cell.\n      _this.selectAll(!e.shiftKey);\n    };\n\n    _this.selectAll = function (shouldUpdateFocusedCell) {\n      var selectionHandler = _this.getEnabledSelectionHandler(RegionCardinality.FULL_TABLE); // clicking on upper left hand corner sets selection to \"all\"\n      // regardless of current selection state (clicking twice does not deselect table)\n\n\n      selectionHandler([Regions.table()]);\n\n      if (shouldUpdateFocusedCell) {\n        var newFocusedCellCoordinates = Regions.getFocusCellCoordinatesFromRegion(Regions.table());\n\n        _this.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));\n      }\n    };\n\n    _this.handleSelectAllHotkey = function (e) {\n      // prevent \"real\" select all from happening as well\n      e.preventDefault();\n      e.stopPropagation(); // selecting-all via the keyboard should not move the focused cell.\n\n      _this.selectAll(false);\n    };\n\n    _this.columnHeaderCellRenderer = function (columnIndex) {\n      var props = _this.getColumnProps(columnIndex);\n\n      if (props === undefined) {\n        return null;\n      }\n\n      var id = props.id,\n          loadingOptions = props.loadingOptions,\n          cellRenderer = props.cellRenderer,\n          columnHeaderCellRenderer = props.columnHeaderCellRenderer,\n          spreadableProps = __rest(props, [\"id\", \"loadingOptions\", \"cellRenderer\", \"columnHeaderCellRenderer\"]);\n\n      var columnLoading = _this.hasLoadingOption(loadingOptions, ColumnLoadingOption.HEADER);\n\n      if (columnHeaderCellRenderer != null) {\n        var columnHeaderCell = columnHeaderCellRenderer(columnIndex);\n        var columnHeaderCellLoading = columnHeaderCell.props.loading;\n        var columnHeaderCellProps = {\n          loading: columnHeaderCellLoading != null ? columnHeaderCellLoading : columnLoading\n        };\n        return React.cloneElement(columnHeaderCell, columnHeaderCellProps);\n      }\n\n      var baseProps = __assign({\n        index: columnIndex,\n        loading: columnLoading\n      }, spreadableProps);\n\n      if (props.name != null) {\n        return React.createElement(ColumnHeaderCell, __assign({}, baseProps));\n      } else {\n        return React.createElement(ColumnHeaderCell, __assign({}, baseProps, {\n          name: Utils.toBase26Alpha(columnIndex)\n        }));\n      }\n    };\n\n    _this.renderColumnHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly) {\n      var _a;\n\n      if (showFrozenColumnsOnly === void 0) {\n        showFrozenColumnsOnly = false;\n      }\n\n      var _b = _this.state,\n          focusedCell = _b.focusedCell,\n          selectedRegions = _b.selectedRegions,\n          viewportRect = _b.viewportRect;\n      var _c = _this.props,\n          enableMultipleSelection = _c.enableMultipleSelection,\n          enableGhostCells = _c.enableGhostCells,\n          enableColumnReordering = _c.enableColumnReordering,\n          enableColumnResizing = _c.enableColumnResizing,\n          loadingOptions = _c.loadingOptions,\n          maxColumnWidth = _c.maxColumnWidth,\n          minColumnWidth = _c.minColumnWidth,\n          selectedRegionTransform = _c.selectedRegionTransform;\n      var classes = classNames(Classes.TABLE_COLUMN_HEADERS, (_a = {}, _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_COLUMNS), _a));\n\n      var columnIndices = _this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);\n\n      var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;\n      var columnIndexEnd = showFrozenColumnsOnly ? _this.getMaxFrozenColumnIndex() : columnIndices.columnIndexEnd;\n      return React.createElement(\"div\", {\n        className: classes\n      }, React.createElement(ColumnHeader, {\n        enableMultipleSelection: enableMultipleSelection,\n        cellRenderer: _this.columnHeaderCellRenderer,\n        focusedCell: focusedCell,\n        grid: _this.grid,\n        isReorderable: enableColumnReordering,\n        isResizable: enableColumnResizing,\n        loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.COLUMN_HEADERS),\n        locator: _this.locator,\n        maxColumnWidth: maxColumnWidth,\n        measurableElementRef: refHandler,\n        minColumnWidth: minColumnWidth,\n        onColumnWidthChanged: _this.handleColumnWidthChanged,\n        onFocusedCell: _this.handleFocus,\n        onLayoutLock: _this.handleLayoutLock,\n        onReordered: _this.handleColumnsReordered,\n        onReordering: reorderingHandler,\n        onResizeGuide: resizeHandler,\n        onSelection: _this.getEnabledSelectionHandler(RegionCardinality.FULL_COLUMNS),\n        selectedRegions: selectedRegions,\n        selectedRegionTransform: selectedRegionTransform,\n        columnIndexStart: columnIndexStart,\n        columnIndexEnd: columnIndexEnd\n      }, _this.props.children), _this.maybeRenderRegions(_this.styleColumnHeaderRegion));\n    };\n\n    _this.renderRowHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly) {\n      var _a;\n\n      if (showFrozenRowsOnly === void 0) {\n        showFrozenRowsOnly = false;\n      }\n\n      var _b = _this.state,\n          focusedCell = _b.focusedCell,\n          selectedRegions = _b.selectedRegions,\n          viewportRect = _b.viewportRect;\n      var _c = _this.props,\n          enableMultipleSelection = _c.enableMultipleSelection,\n          enableGhostCells = _c.enableGhostCells,\n          enableRowReordering = _c.enableRowReordering,\n          enableRowResizing = _c.enableRowResizing,\n          loadingOptions = _c.loadingOptions,\n          maxRowHeight = _c.maxRowHeight,\n          minRowHeight = _c.minRowHeight,\n          rowHeaderCellRenderer = _c.rowHeaderCellRenderer,\n          selectedRegionTransform = _c.selectedRegionTransform;\n      var classes = classNames(Classes.TABLE_ROW_HEADERS, (_a = {}, _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_ROWS), _a));\n\n      var rowIndices = _this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n\n      var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;\n      var rowIndexEnd = showFrozenRowsOnly ? _this.getMaxFrozenRowIndex() : rowIndices.rowIndexEnd;\n      return React.createElement(\"div\", {\n        className: classes,\n        ref: refHandler\n      }, React.createElement(RowHeader, {\n        enableMultipleSelection: enableMultipleSelection,\n        focusedCell: focusedCell,\n        grid: _this.grid,\n        locator: _this.locator,\n        isReorderable: enableRowReordering,\n        isResizable: enableRowResizing,\n        loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.ROW_HEADERS),\n        maxRowHeight: maxRowHeight,\n        minRowHeight: minRowHeight,\n        onFocusedCell: _this.handleFocus,\n        onLayoutLock: _this.handleLayoutLock,\n        onResizeGuide: resizeHandler,\n        onReordered: _this.handleRowsReordered,\n        onReordering: reorderingHandler,\n        onRowHeightChanged: _this.handleRowHeightChanged,\n        onSelection: _this.getEnabledSelectionHandler(RegionCardinality.FULL_ROWS),\n        rowHeaderCellRenderer: rowHeaderCellRenderer,\n        selectedRegions: selectedRegions,\n        selectedRegionTransform: selectedRegionTransform,\n        rowIndexStart: rowIndexStart,\n        rowIndexEnd: rowIndexEnd\n      }), _this.maybeRenderRegions(_this.styleRowHeaderRegion));\n    };\n\n    _this.bodyCellRenderer = function (rowIndex, columnIndex) {\n      var columnProps = _this.getColumnProps(columnIndex);\n\n      if (columnProps === undefined) {\n        return null;\n      }\n\n      var id = columnProps.id,\n          loadingOptions = columnProps.loadingOptions,\n          cellRenderer = columnProps.cellRenderer,\n          columnHeaderCellRenderer = columnProps.columnHeaderCellRenderer,\n          name = columnProps.name,\n          nameRenderer = columnProps.nameRenderer,\n          restColumnProps = __rest(columnProps, [\"id\", \"loadingOptions\", \"cellRenderer\", \"columnHeaderCellRenderer\", \"name\", \"nameRenderer\"]);\n\n      var cell = cellRenderer(rowIndex, columnIndex);\n      var _a = cell.props.loading,\n          loading = _a === void 0 ? _this.hasLoadingOption(loadingOptions, ColumnLoadingOption.CELLS) : _a;\n\n      var cellProps = __assign(__assign({}, restColumnProps), {\n        loading: loading\n      });\n\n      return React.cloneElement(cell, cellProps);\n    };\n\n    _this.renderBody = function (quadrantType, showFrozenRowsOnly, showFrozenColumnsOnly) {\n      if (showFrozenRowsOnly === void 0) {\n        showFrozenRowsOnly = false;\n      }\n\n      if (showFrozenColumnsOnly === void 0) {\n        showFrozenColumnsOnly = false;\n      }\n\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          numFrozenColumns = _a.numFrozenColumnsClamped,\n          numFrozenRows = _a.numFrozenRowsClamped,\n          selectedRegions = _a.selectedRegions,\n          viewportRect = _a.viewportRect;\n      var _b = _this.props,\n          enableMultipleSelection = _b.enableMultipleSelection,\n          enableGhostCells = _b.enableGhostCells,\n          loadingOptions = _b.loadingOptions,\n          bodyContextMenuRenderer = _b.bodyContextMenuRenderer,\n          selectedRegionTransform = _b.selectedRegionTransform;\n\n      var rowIndices = _this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n\n      var columnIndices = _this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells); // start beyond the frozen area if rendering unrelated quadrants, so we\n      // don't render duplicate cells underneath the frozen ones.\n\n\n      var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart + numFrozenColumns;\n      var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart + numFrozenRows; // if rendering frozen rows/columns, subtract one to convert to\n      // 0-indexing. if the 1-indexed value is 0, this sets the end index\n      // to -1, which avoids rendering absent frozen rows/columns at all.\n\n      var columnIndexEnd = showFrozenColumnsOnly ? numFrozenColumns - 1 : columnIndices.columnIndexEnd;\n      var rowIndexEnd = showFrozenRowsOnly ? numFrozenRows - 1 : rowIndices.rowIndexEnd; // the main quadrant contains all cells in the table, so listen only to that quadrant\n\n      var onCompleteRender = quadrantType === QuadrantType.MAIN ? _this.handleCompleteRender : undefined;\n      return React.createElement(\"div\", null, React.createElement(TableBody, {\n        enableMultipleSelection: enableMultipleSelection,\n        cellRenderer: _this.bodyCellRenderer,\n        focusedCell: focusedCell,\n        grid: _this.grid,\n        loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.CELLS),\n        locator: _this.locator,\n        onCompleteRender: onCompleteRender,\n        onFocusedCell: _this.handleFocus,\n        onSelection: _this.getEnabledSelectionHandler(RegionCardinality.CELLS),\n        bodyContextMenuRenderer: bodyContextMenuRenderer,\n        renderMode: _this.getNormalizedRenderMode(),\n        selectedRegions: selectedRegions,\n        selectedRegionTransform: selectedRegionTransform,\n        viewportRect: viewportRect,\n        columnIndexStart: columnIndexStart,\n        columnIndexEnd: columnIndexEnd,\n        rowIndexStart: rowIndexStart,\n        rowIndexEnd: rowIndexEnd,\n        numFrozenColumns: showFrozenColumnsOnly ? numFrozenColumns : undefined,\n        numFrozenRows: showFrozenRowsOnly ? numFrozenRows : undefined\n      }), _this.maybeRenderRegions(_this.styleBodyRegion, quadrantType));\n    };\n\n    _this.handleCompleteRender = function () {\n      var _a, _b; // the first onCompleteRender is triggered before the viewportRect is\n      // defined and the second after the viewportRect has been set. the cells\n      // will only actually render once the viewportRect is defined though, so\n      // we defer invoking onCompleteRender until that check passes.\n\n\n      if (_this.state.viewportRect != null) {\n        (_b = (_a = _this.props).onCompleteRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n        _this.didCompletelyMount = true;\n      }\n    };\n\n    _this.handleFocusMoveLeft = function (e) {\n      return _this.handleFocusMove(e, \"left\");\n    };\n\n    _this.handleFocusMoveLeftInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"left\");\n    };\n\n    _this.handleFocusMoveRight = function (e) {\n      return _this.handleFocusMove(e, \"right\");\n    };\n\n    _this.handleFocusMoveRightInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"right\");\n    };\n\n    _this.handleFocusMoveUp = function (e) {\n      return _this.handleFocusMove(e, \"up\");\n    };\n\n    _this.handleFocusMoveUpInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"up\");\n    };\n\n    _this.handleFocusMoveDown = function (e) {\n      return _this.handleFocusMove(e, \"down\");\n    };\n\n    _this.handleFocusMoveDownInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"down\");\n    };\n\n    _this.styleBodyRegion = function (region, quadrantType) {\n      var numFrozenColumns = _this.props.numFrozenColumns;\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region); // ensure we're not showing borders at the boundary of the frozen-columns area\n\n\n      var canHideRightBorder = (quadrantType === QuadrantType.TOP_LEFT || quadrantType === QuadrantType.LEFT) && numFrozenColumns != null && numFrozenColumns > 0;\n\n      var fixedHeight = _this.grid.getHeight();\n\n      var fixedWidth = _this.grid.getWidth(); // include a correction in some cases to hide borders along quadrant boundaries\n\n\n      var alignmentCorrection = 1;\n      var alignmentCorrectionString = \"-\" + alignmentCorrection + \"px\";\n\n      switch (cardinality) {\n        case RegionCardinality.CELLS:\n          return style;\n\n        case RegionCardinality.FULL_COLUMNS:\n          style.top = alignmentCorrectionString;\n          style.height = fixedHeight + alignmentCorrection;\n          return style;\n\n        case RegionCardinality.FULL_ROWS:\n          style.left = alignmentCorrectionString;\n          style.width = fixedWidth + alignmentCorrection;\n\n          if (canHideRightBorder) {\n            style.right = alignmentCorrectionString;\n          }\n\n          return style;\n\n        case RegionCardinality.FULL_TABLE:\n          style.left = alignmentCorrectionString;\n          style.top = alignmentCorrectionString;\n          style.width = fixedWidth + alignmentCorrection;\n          style.height = fixedHeight + alignmentCorrection;\n\n          if (canHideRightBorder) {\n            style.right = alignmentCorrectionString;\n          }\n\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.styleMenuRegion = function (region) {\n      var viewportRect = _this.state.viewportRect;\n\n      if (viewportRect == null) {\n        return {};\n      }\n\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          style.right = \"0px\";\n          style.bottom = \"0px\";\n          style.top = \"0px\";\n          style.left = \"0px\";\n          style.borderBottom = \"none\";\n          style.borderRight = \"none\";\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.styleColumnHeaderRegion = function (region) {\n      var viewportRect = _this.state.viewportRect;\n\n      if (viewportRect == null) {\n        return {};\n      }\n\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          style.left = \"-1px\";\n          style.borderLeft = \"none\";\n          style.bottom = \"-1px\";\n          return style;\n\n        case RegionCardinality.FULL_COLUMNS:\n          style.bottom = \"-1px\";\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.styleRowHeaderRegion = function (region) {\n      var viewportRect = _this.state.viewportRect;\n\n      if (viewportRect == null) {\n        return {};\n      }\n\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          style.top = \"-1px\";\n          style.borderTop = \"none\";\n          style.right = \"-1px\";\n          return style;\n\n        case RegionCardinality.FULL_ROWS:\n          style.right = \"-1px\";\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.handleColumnWidthChanged = function (columnIndex, width) {\n      var selectedRegions = _this.state.selectedRegions;\n\n      var columnWidths = _this.state.columnWidths.slice();\n\n      if (Regions.hasFullTable(selectedRegions)) {\n        for (var col = 0; col < columnWidths.length; col++) {\n          columnWidths[col] = width;\n        }\n      }\n\n      if (Regions.hasFullColumn(selectedRegions, columnIndex)) {\n        Regions.eachUniqueFullColumn(selectedRegions, function (col) {\n          columnWidths[col] = width;\n        });\n      } else {\n        columnWidths[columnIndex] = width;\n      }\n\n      _this.invalidateGrid();\n\n      _this.setState({\n        columnWidths: columnWidths\n      });\n\n      var onColumnWidthChanged = _this.props.onColumnWidthChanged;\n\n      if (onColumnWidthChanged != null) {\n        onColumnWidthChanged(columnIndex, width);\n      }\n    };\n\n    _this.handleRowHeightChanged = function (rowIndex, height) {\n      var selectedRegions = _this.state.selectedRegions;\n\n      var rowHeights = _this.state.rowHeights.slice();\n\n      if (Regions.hasFullTable(selectedRegions)) {\n        for (var row = 0; row < rowHeights.length; row++) {\n          rowHeights[row] = height;\n        }\n      }\n\n      if (Regions.hasFullRow(selectedRegions, rowIndex)) {\n        Regions.eachUniqueFullRow(selectedRegions, function (row) {\n          rowHeights[row] = height;\n        });\n      } else {\n        rowHeights[rowIndex] = height;\n      }\n\n      _this.invalidateGrid();\n\n      _this.setState({\n        rowHeights: rowHeights\n      });\n\n      var onRowHeightChanged = _this.props.onRowHeightChanged;\n\n      if (onRowHeightChanged != null) {\n        onRowHeightChanged(rowIndex, height);\n      }\n    };\n\n    _this.handleRootScroll = function (_event) {\n      // Bug #211 - Native browser text selection events can cause the root\n      // element to scroll even though it has a overflow:hidden style. The\n      // only viable solution to this is to unscroll the element after the\n      // browser scrolls it.\n      if (_this.rootTableElement != null) {\n        _this.rootTableElement.scrollLeft = 0;\n        _this.rootTableElement.scrollTop = 0;\n      }\n    };\n\n    _this.handleBodyScroll = function (event) {\n      // Prevent the event from propagating to avoid a resize event on the\n      // resize sensor.\n      event.stopPropagation();\n\n      if (_this.locator != null && !_this.state.isLayoutLocked) {\n        var viewportRect = _this.locator.getViewportRect();\n\n        _this.updateViewportRect(viewportRect);\n      }\n    };\n\n    _this.clearSelection = function (_selectedRegions) {\n      _this.handleSelection([]);\n    }; // no good way to call arrow-key keyboard events from tests\n\n    /* istanbul ignore next */\n\n\n    _this.handleFocusMove = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var focusedCell = _this.state.focusedCell;\n\n      if (focusedCell == null) {\n        // halt early if we have a selectedRegionTransform or something else in play that nixes\n        // the focused cell.\n        return;\n      }\n\n      var newFocusedCell = {\n        col: focusedCell.col,\n        focusSelectionIndex: 0,\n        row: focusedCell.row\n      };\n\n      switch (direction) {\n        case \"up\":\n          newFocusedCell.row -= 1;\n          break;\n\n        case \"down\":\n          newFocusedCell.row += 1;\n          break;\n\n        case \"left\":\n          newFocusedCell.col -= 1;\n          break;\n\n        case \"right\":\n          newFocusedCell.col += 1;\n          break;\n\n        default:\n          break;\n      }\n\n      if (newFocusedCell.row < 0 || newFocusedCell.row >= _this.grid.numRows || newFocusedCell.col < 0 || newFocusedCell.col >= _this.grid.numCols) {\n        return;\n      } // change selection to match new focus cell location\n\n\n      var newSelectionRegions = [Regions.cell(newFocusedCell.row, newFocusedCell.col)];\n      var selectedRegionTransform = _this.props.selectedRegionTransform;\n      var transformedSelectionRegions = selectedRegionTransform != null ? newSelectionRegions.map(function (region) {\n        return selectedRegionTransform(region, e);\n      }) : newSelectionRegions;\n\n      _this.handleSelection(transformedSelectionRegions);\n\n      _this.handleFocus(newFocusedCell); // keep the focused cell in view\n\n\n      _this.scrollBodyToFocusedCell(newFocusedCell);\n    }; // no good way to call arrow-key keyboard events from tests\n\n    /* istanbul ignore next */\n\n\n    _this.handleFocusMoveInternal = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n\n      if (focusedCell == null) {\n        // halt early if we have a selectedRegionTransform or something else in play that nixes\n        // the focused cell.\n        return;\n      }\n\n      var newFocusedCell = {\n        col: focusedCell.col,\n        focusSelectionIndex: focusedCell.focusSelectionIndex,\n        row: focusedCell.row\n      }; // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one\n\n      if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {\n        var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[0], _this.grid.numRows, _this.grid.numCols);\n        newFocusedCell = {\n          col: focusCellRegion.cols[0],\n          focusSelectionIndex: 0,\n          row: focusCellRegion.rows[0]\n        };\n      } else {\n        if (selectedRegions.length === 0) {\n          _this.handleFocusMove(e, direction);\n\n          return;\n        }\n\n        var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], _this.grid.numRows, _this.grid.numCols);\n\n        if (focusCellRegion.cols[0] === focusCellRegion.cols[1] && focusCellRegion.rows[0] === focusCellRegion.rows[1] && selectedRegions.length === 1) {\n          _this.handleFocusMove(e, direction);\n\n          return;\n        }\n\n        switch (direction) {\n          case \"up\":\n            newFocusedCell = _this.moveFocusCell(\"row\", \"col\", true, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"left\":\n            newFocusedCell = _this.moveFocusCell(\"col\", \"row\", true, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"down\":\n            newFocusedCell = _this.moveFocusCell(\"row\", \"col\", false, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"right\":\n            newFocusedCell = _this.moveFocusCell(\"col\", \"row\", false, newFocusedCell, focusCellRegion);\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (newFocusedCell.row < 0 || newFocusedCell.row >= _this.grid.numRows || newFocusedCell.col < 0 || newFocusedCell.col >= _this.grid.numCols) {\n        return;\n      }\n\n      _this.handleFocus(newFocusedCell); // keep the focused cell in view\n\n\n      _this.scrollBodyToFocusedCell(newFocusedCell);\n    };\n\n    _this.scrollBodyToFocusedCell = function (focusedCell) {\n      var row = focusedCell.row,\n          col = focusedCell.col;\n      var viewportRect = _this.state.viewportRect; // sort keys in normal CSS position order (per the trusty TRBL/\"trouble\" acronym)\n      // tslint:disable:object-literal-sort-keys\n\n      var viewportBounds = {\n        top: viewportRect.top,\n        right: viewportRect.left + viewportRect.width,\n        bottom: viewportRect.top + viewportRect.height,\n        left: viewportRect.left\n      };\n      var focusedCellBounds = {\n        top: _this.grid.getCumulativeHeightBefore(row),\n        right: _this.grid.getCumulativeWidthAt(col),\n        bottom: _this.grid.getCumulativeHeightAt(row),\n        left: _this.grid.getCumulativeWidthBefore(col)\n      }; // tslint:enable:object-literal-sort-keys\n\n      var focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;\n      var focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;\n      var isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;\n      var isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;\n      var ss = {}; // keep the top end of an overly tall focused cell in view when moving left and right\n      // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)\n\n      if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {\n        // scroll up (minus one pixel to avoid clipping the focused-cell border)\n        ss.nextScrollTop = Math.max(0, focusedCellBounds.top - 1);\n      } else if (focusedCellBounds.bottom > viewportBounds.bottom) {\n        // scroll down\n        var scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;\n        ss.nextScrollTop = viewportBounds.top + scrollDelta;\n      } // keep the left end of an overly wide focused cell in view when moving up and down\n\n\n      if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {\n        // scroll left (again minus one additional pixel)\n        ss.nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);\n      } else if (focusedCellBounds.right > viewportBounds.right) {\n        // scroll right\n        var scrollDelta = focusedCellBounds.right - viewportBounds.right;\n        ss.nextScrollLeft = viewportBounds.left + scrollDelta;\n      }\n\n      _this.syncViewportPosition(ss);\n    };\n\n    _this.handleFocus = function (focusedCell) {\n      var _a, _b;\n\n      if (!_this.props.enableFocusedCell) {\n        // don't set focus state if focus is not allowed\n        return;\n      } // only set focused cell state if not specified in props\n\n\n      if (_this.props.focusedCell == null) {\n        _this.setState({\n          focusedCell: focusedCell\n        });\n      }\n\n      (_b = (_a = _this.props).onFocusedCell) === null || _b === void 0 ? void 0 : _b.call(_a, focusedCell);\n    };\n\n    _this.handleSelection = function (selectedRegions) {\n      // only set selectedRegions state if not specified in props\n      if (_this.props.selectedRegions == null) {\n        _this.setState({\n          selectedRegions: selectedRegions\n        });\n      }\n\n      var onSelection = _this.props.onSelection;\n\n      if (onSelection != null) {\n        onSelection(selectedRegions);\n      }\n    };\n\n    _this.handleColumnsReordering = function (verticalGuides) {\n      _this.setState({\n        isReordering: true,\n        verticalGuides: verticalGuides\n      });\n    };\n\n    _this.handleColumnsReordered = function (oldIndex, newIndex, length) {\n      var _a, _b;\n\n      _this.setState({\n        isReordering: false,\n        verticalGuides: undefined\n      });\n\n      (_b = (_a = _this.props).onColumnsReordered) === null || _b === void 0 ? void 0 : _b.call(_a, oldIndex, newIndex, length);\n    };\n\n    _this.handleRowsReordering = function (horizontalGuides) {\n      _this.setState({\n        isReordering: true,\n        horizontalGuides: horizontalGuides\n      });\n    };\n\n    _this.handleRowsReordered = function (oldIndex, newIndex, length) {\n      var _a, _b;\n\n      _this.setState({\n        isReordering: false,\n        horizontalGuides: undefined\n      });\n\n      (_b = (_a = _this.props).onRowsReordered) === null || _b === void 0 ? void 0 : _b.call(_a, oldIndex, newIndex, length);\n    };\n\n    _this.handleLayoutLock = function (isLayoutLocked) {\n      if (isLayoutLocked === void 0) {\n        isLayoutLocked = false;\n      }\n\n      _this.setState({\n        isLayoutLocked: isLayoutLocked\n      });\n    };\n\n    _this.hasLoadingOption = function (loadingOptions, loadingOption) {\n      if (loadingOptions == null) {\n        return undefined;\n      }\n\n      return loadingOptions.indexOf(loadingOption) >= 0;\n    };\n\n    _this.updateViewportRect = function (nextViewportRect) {\n      var viewportRect = _this.state.viewportRect;\n\n      _this.setState({\n        viewportRect: nextViewportRect\n      });\n\n      var didViewportChange = viewportRect != null && !viewportRect.equals(nextViewportRect) || viewportRect == null && nextViewportRect != null;\n\n      if (didViewportChange) {\n        _this.invokeOnVisibleCellsChangeCallback(nextViewportRect);\n      }\n    };\n\n    _this.getMaxFrozenColumnIndex = function () {\n      var numFrozenColumns = _this.state.numFrozenColumnsClamped;\n      return numFrozenColumns != null ? numFrozenColumns - 1 : undefined;\n    };\n\n    _this.getMaxFrozenRowIndex = function () {\n      var numFrozenRows = _this.state.numFrozenRowsClamped;\n      return numFrozenRows != null ? numFrozenRows - 1 : undefined;\n    };\n\n    _this.handleColumnResizeGuide = function (verticalGuides) {\n      _this.setState({\n        verticalGuides: verticalGuides\n      });\n    };\n\n    _this.handleRowResizeGuide = function (horizontalGuides) {\n      _this.setState({\n        horizontalGuides: horizontalGuides\n      });\n    };\n\n    var _a = _this.props,\n        children = _a.children,\n        columnWidths = _a.columnWidths,\n        defaultRowHeight = _a.defaultRowHeight,\n        defaultColumnWidth = _a.defaultColumnWidth,\n        numRows = _a.numRows,\n        rowHeights = _a.rowHeights;\n    var childrenArray = React.Children.toArray(children);\n    var columnIdToIndex = Table_1.createColumnIdIndex(childrenArray); // Create height/width arrays using the lengths from props and\n    // children, the default values from props, and finally any sparse\n    // arrays passed into props.\n\n    var newColumnWidths = childrenArray.map(function () {\n      return defaultColumnWidth;\n    });\n    newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);\n    var newRowHeights = Utils.times(numRows, function () {\n      return defaultRowHeight;\n    });\n    newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);\n    var selectedRegions = props.selectedRegions == null ? [] : props.selectedRegions;\n    var focusedCell = FocusedCellUtils.getInitialFocusedCell(props.enableFocusedCell, props.focusedCell, undefined, selectedRegions);\n    _this.state = {\n      childrenArray: childrenArray,\n      columnIdToIndex: columnIdToIndex,\n      columnWidths: newColumnWidths,\n      focusedCell: focusedCell,\n      isLayoutLocked: false,\n      isReordering: false,\n      numFrozenColumnsClamped: clampNumFrozenColumns(props),\n      numFrozenRowsClamped: clampNumFrozenRows(props),\n      rowHeights: newRowHeights,\n      selectedRegions: selectedRegions\n    };\n    return _this;\n  }\n\n  Table_1 = Table;\n\n  Table.getDerivedStateFromProps = function (props, state) {\n    var children = props.children,\n        defaultColumnWidth = props.defaultColumnWidth,\n        defaultRowHeight = props.defaultRowHeight,\n        enableFocusedCell = props.enableFocusedCell,\n        focusedCell = props.focusedCell,\n        numRows = props.numRows,\n        selectedRegions = props.selectedRegions,\n        selectionModes = props.selectionModes; // assign values from state if uncontrolled\n\n    var columnWidths = props.columnWidths,\n        rowHeights = props.rowHeights;\n\n    if (columnWidths == null) {\n      columnWidths = state.columnWidths;\n    }\n\n    if (rowHeights == null) {\n      rowHeights = state.rowHeights;\n    }\n\n    var newChildrenArray = React.Children.toArray(children);\n    var didChildrenChange = newChildrenArray !== state.childrenArray;\n    var numCols = newChildrenArray.length;\n    var newColumnWidths = columnWidths;\n\n    if (columnWidths !== state.columnWidths || didChildrenChange) {\n      // Try to maintain widths of columns by looking up the width of the\n      // column that had the same `ID` prop. If none is found, use the\n      // previous width at the same index.\n      var previousColumnWidths = newChildrenArray.map(function (child, index) {\n        var mappedIndex = state.columnIdToIndex[child.props.id];\n        return state.columnWidths[mappedIndex != null ? mappedIndex : index];\n      }); // Make sure the width/height arrays have the correct length, but keep\n      // as many existing widths/heights as possible. Also, apply the\n      // sparse width/heights from props.\n\n      newColumnWidths = Utils.arrayOfLength(newColumnWidths, numCols, defaultColumnWidth);\n      newColumnWidths = Utils.assignSparseValues(newColumnWidths, previousColumnWidths);\n      newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);\n    }\n\n    var newRowHeights = rowHeights;\n\n    if (rowHeights !== state.rowHeights || numRows !== state.rowHeights.length) {\n      newRowHeights = Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);\n      newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);\n    }\n\n    var newSelectedRegions = selectedRegions;\n\n    if (selectedRegions == null) {\n      // if we're in uncontrolled mode, filter out all selected regions that don't\n      // fit in the current new table dimensions\n      newSelectedRegions = state.selectedRegions.filter(function (region) {\n        var regionCardinality = Regions.getRegionCardinality(region);\n        return Table_1.isSelectionModeEnabled(props, regionCardinality, selectionModes) && Regions.isRegionValidForTable(region, numRows, numCols);\n      });\n    }\n\n    var newFocusedCell = FocusedCellUtils.getInitialFocusedCell(enableFocusedCell, focusedCell, state.focusedCell, newSelectedRegions);\n    var nextState = {\n      childrenArray: newChildrenArray,\n      columnIdToIndex: didChildrenChange ? Table_1.createColumnIdIndex(newChildrenArray) : state.columnIdToIndex,\n      columnWidths: newColumnWidths,\n      focusedCell: newFocusedCell,\n      numFrozenColumnsClamped: clampNumFrozenColumns(props),\n      numFrozenRowsClamped: clampNumFrozenRows(props),\n      rowHeights: newRowHeights,\n      selectedRegions: newSelectedRegions\n    };\n\n    if (!CoreUtils.deepCompareKeys(state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_DENYLIST)) {\n      return nextState;\n    }\n\n    return null;\n  };\n\n  Table.createColumnIdIndex = function (children) {\n    var columnIdToIndex = {};\n\n    for (var i = 0; i < children.length; i++) {\n      var key = children[i].props.id;\n\n      if (key != null) {\n        columnIdToIndex[String(key)] = i;\n      }\n    }\n\n    return columnIdToIndex;\n  };\n\n  Table.isSelectionModeEnabled = function (props, selectionMode, selectionModes) {\n    if (selectionModes === void 0) {\n      selectionModes = props.selectionModes;\n    }\n\n    var children = props.children,\n        numRows = props.numRows;\n    var numColumns = React.Children.count(children);\n    return selectionModes.indexOf(selectionMode) >= 0 && numRows > 0 && numColumns > 0;\n  }; // Instance methods\n  // ================\n\n  /**\n   * __Experimental!__ Resizes all rows in the table to the approximate\n   * maximum height of wrapped cell content in each row. Works best when each\n   * cell contains plain text of a consistent font style (though font style\n   * may vary between cells). Since this function uses approximate\n   * measurements, results may not be perfect.\n   *\n   * Approximation parameters can be configured for the entire table or on a\n   * per-cell basis. Default values are fine-tuned to work well with default\n   * Table font styles.\n   */\n\n\n  Table.prototype.resizeRowsByApproximateHeight = function (getCellText, options) {\n    var numRows = this.props.numRows;\n    var columnWidths = this.state.columnWidths;\n    var numColumns = columnWidths.length;\n    var rowHeights = [];\n\n    for (var rowIndex = 0; rowIndex < numRows; rowIndex++) {\n      var maxCellHeightInRow = 0; // iterate through each cell in the row\n\n      for (var columnIndex = 0; columnIndex < numColumns; columnIndex++) {\n        // resolve all parameters to raw values\n        var _a = this.resolveResizeRowsByApproximateHeightOptions(options, rowIndex, columnIndex),\n            approxCharWidth = _a.getApproximateCharWidth,\n            approxLineHeight = _a.getApproximateLineHeight,\n            horizontalPadding = _a.getCellHorizontalPadding,\n            numBufferLines = _a.getNumBufferLines;\n\n        var cellText = getCellText(rowIndex, columnIndex);\n        var approxCellHeight = Utils.getApproxCellHeight(cellText, columnWidths[columnIndex], approxCharWidth, approxLineHeight, horizontalPadding, numBufferLines);\n\n        if (approxCellHeight > maxCellHeightInRow) {\n          maxCellHeightInRow = approxCellHeight;\n        }\n      }\n\n      rowHeights.push(maxCellHeightInRow);\n    }\n\n    this.invalidateGrid();\n    this.setState({\n      rowHeights: rowHeights\n    });\n  };\n  /**\n   * Resize all rows in the table to the height of the tallest visible cell in the specified columns.\n   * If no indices are provided, default to using the tallest visible cell from all columns in view.\n   */\n\n\n  Table.prototype.resizeRowsByTallestCell = function (columnIndices) {\n    var _this = this;\n\n    var tallest = 0;\n\n    if (columnIndices == null) {\n      // Consider all columns currently in viewport\n      var viewportColumnIndices = this.grid.getColumnIndicesInRect(this.state.viewportRect);\n\n      for (var col = viewportColumnIndices.columnIndexStart; col <= viewportColumnIndices.columnIndexEnd; col++) {\n        tallest = Math.max(tallest, this.locator.getTallestVisibleCellInColumn(col));\n      }\n    } else {\n      var columnIndicesArray = Array.isArray(columnIndices) ? columnIndices : [columnIndices];\n      var tallestByColumns = columnIndicesArray.map(function (col) {\n        return _this.locator.getTallestVisibleCellInColumn(col);\n      });\n      tallest = Math.max.apply(Math, tallestByColumns);\n    }\n\n    var rowHeights = Array(this.state.rowHeights.length).fill(tallest);\n    this.invalidateGrid();\n    this.setState({\n      rowHeights: rowHeights\n    });\n  };\n  /**\n   * Scrolls the table to the target region in a fashion appropriate to the target region's\n   * cardinality:\n   *\n   * - CELLS: Scroll the top-left cell in the target region to the top-left corner of the viewport.\n   * - FULL_ROWS: Scroll the top-most row in the target region to the top of the viewport.\n   * - FULL_COLUMNS: Scroll the left-most column in the target region to the left side of the viewport.\n   * - FULL_TABLE: Scroll the top-left cell in the table to the top-left corner of the viewport.\n   *\n   * If there are active frozen rows and/or columns, the target region will be positioned in the\n   * top-left corner of the non-frozen area (unless the target region itself is in the frozen\n   * area).\n   *\n   * If the target region is close to the bottom-right corner of the table, this function will\n   * simply scroll the target region as close to the top-left as possible until the bottom-right\n   * corner is reached.\n   */\n\n\n  Table.prototype.scrollToRegion = function (region) {\n    var _a = this.state,\n        numFrozenColumns = _a.numFrozenColumnsClamped,\n        numFrozenRows = _a.numFrozenRowsClamped;\n    var _b = this.state.viewportRect,\n        currScrollLeft = _b.left,\n        currScrollTop = _b.top;\n\n    var _c = ScrollUtils.getScrollPositionForRegion(region, currScrollLeft, currScrollTop, this.grid.getCumulativeWidthBefore, this.grid.getCumulativeHeightBefore, numFrozenRows, numFrozenColumns),\n        scrollLeft = _c.scrollLeft,\n        scrollTop = _c.scrollTop;\n\n    var correctedScrollLeft = this.shouldDisableHorizontalScroll() ? 0 : scrollLeft;\n    var correctedScrollTop = this.shouldDisableVerticalScroll() ? 0 : scrollTop; // defer to the quadrant stack to keep all quadrant positions in sync\n\n    this.quadrantStackInstance.scrollToPosition(correctedScrollLeft, correctedScrollTop);\n  }; // React lifecycle\n  // ===============\n\n\n  Table.prototype.getChildContext = function () {\n    return {\n      enableColumnInteractionBar: this.props.enableColumnInteractionBar\n    };\n  };\n\n  Table.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    var propKeysDenylist = {\n      exclude: Table_1.SHALLOW_COMPARE_PROP_KEYS_DENYLIST\n    };\n    var stateKeysDenylist = {\n      exclude: Table_1.SHALLOW_COMPARE_STATE_KEYS_DENYLIST\n    };\n    return !CoreUtils.shallowCompareKeys(this.props, nextProps, propKeysDenylist) || !CoreUtils.shallowCompareKeys(this.state, nextState, stateKeysDenylist) || !CoreUtils.deepCompareKeys(this.props, nextProps, Table_1.SHALLOW_COMPARE_PROP_KEYS_DENYLIST) || !CoreUtils.deepCompareKeys(this.state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_DENYLIST);\n  };\n\n  Table.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        children = _b.children,\n        className = _b.className,\n        enableRowHeader = _b.enableRowHeader,\n        loadingOptions = _b.loadingOptions,\n        numRows = _b.numRows,\n        enableColumnInteractionBar = _b.enableColumnInteractionBar;\n    var _c = this.state,\n        horizontalGuides = _c.horizontalGuides,\n        numFrozenColumnsClamped = _c.numFrozenColumnsClamped,\n        numFrozenRowsClamped = _c.numFrozenRowsClamped,\n        verticalGuides = _c.verticalGuides;\n\n    if (!this.gridDimensionsMatchProps()) {\n      // Ensure we're rendering the correct number of rows & columns\n      this.invalidateGrid();\n    }\n\n    this.validateGrid();\n    var classes = classNames(Classes.TABLE_CONTAINER, (_a = {}, _a[Classes.TABLE_REORDERING] = this.state.isReordering, _a[Classes.TABLE_NO_VERTICAL_SCROLL] = this.shouldDisableVerticalScroll(), _a[Classes.TABLE_NO_HORIZONTAL_SCROLL] = this.shouldDisableHorizontalScroll(), _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(this.props, RegionCardinality.CELLS), _a[Classes.TABLE_NO_ROWS] = numRows === 0, _a), className);\n    return React.createElement(\"div\", {\n      className: classes,\n      ref: this.refHandlers.rootTable,\n      onScroll: this.handleRootScroll\n    }, React.createElement(TableQuadrantStack, {\n      bodyRef: this.refHandlers.cellContainer,\n      bodyRenderer: this.renderBody,\n      columnHeaderCellRenderer: this.renderColumnHeader,\n      columnHeaderRef: this.refHandlers.columnHeader,\n      enableColumnInteractionBar: enableColumnInteractionBar,\n      enableRowHeader: enableRowHeader,\n      grid: this.grid,\n      handleColumnResizeGuide: this.handleColumnResizeGuide,\n      handleColumnsReordering: this.handleColumnsReordering,\n      handleRowResizeGuide: this.handleRowResizeGuide,\n      handleRowsReordering: this.handleRowsReordering,\n      isHorizontalScrollDisabled: this.shouldDisableHorizontalScroll(),\n      isVerticalScrollDisabled: this.shouldDisableVerticalScroll(),\n      loadingOptions: loadingOptions,\n      numColumns: React.Children.count(children),\n      numFrozenColumns: numFrozenColumnsClamped,\n      numFrozenRows: numFrozenRowsClamped,\n      numRows: numRows,\n      onScroll: this.handleBodyScroll,\n      ref: this.refHandlers.quadrantStack,\n      menuRenderer: this.renderMenu,\n      rowHeaderCellRenderer: this.renderRowHeader,\n      rowHeaderRef: this.refHandlers.rowHeader,\n      scrollContainerRef: this.refHandlers.scrollContainer\n    }), React.createElement(\"div\", {\n      className: classNames(Classes.TABLE_OVERLAY_LAYER, Classes.TABLE_OVERLAY_REORDERING_CURSOR)\n    }), React.createElement(GuideLayer, {\n      className: Classes.TABLE_RESIZE_GUIDES,\n      verticalGuides: verticalGuides,\n      horizontalGuides: horizontalGuides\n    }));\n  };\n\n  Table.prototype.renderHotkeys = function () {\n    var hotkeys = [this.maybeRenderCopyHotkey(), this.maybeRenderSelectAllHotkey(), this.maybeRenderFocusHotkeys(), this.maybeRenderSelectionResizeHotkeys()];\n    return React.createElement(Hotkeys, null, hotkeys.filter(function (element) {\n      return element !== undefined;\n    }));\n  };\n  /**\n   * When the component mounts, the HTML Element refs will be available, so\n   * we constructor the Locator, which queries the elements' bounding\n   * ClientRects.\n   */\n\n\n  Table.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this.validateGrid();\n    this.locator = new Locator(this.rootTableElement, this.scrollContainerElement, this.cellContainerElement);\n    this.updateLocator();\n    this.updateViewportRect(this.locator.getViewportRect());\n    this.resizeSensorDetach = ResizeSensor.attach(this.rootTableElement, function () {\n      if (!_this.state.isLayoutLocked) {\n        _this.updateViewportRect(_this.locator.getViewportRect());\n      }\n    });\n  };\n\n  Table.prototype.componentWillUnmount = function () {\n    if (this.resizeSensorDetach != null) {\n      this.resizeSensorDetach();\n      delete this.resizeSensorDetach;\n    }\n\n    this.didCompletelyMount = false;\n  };\n\n  Table.prototype.getSnapshotBeforeUpdate = function () {\n    var viewportRect = this.state.viewportRect;\n    this.validateGrid();\n    var tableBottom = this.grid.getCumulativeHeightAt(this.grid.numRows - 1);\n    var tableRight = this.grid.getCumulativeWidthAt(this.grid.numCols - 1);\n    var nextScrollTop = tableBottom < viewportRect.top + viewportRect.height ? // scroll the last row into view\n    Math.max(0, tableBottom - viewportRect.height) : undefined;\n    var nextScrollLeft = tableRight < viewportRect.left + viewportRect.width ? // scroll the last column into view\n    Math.max(0, tableRight - viewportRect.width) : undefined; // these will only be defined if they differ from viewportRect\n\n    return {\n      nextScrollLeft: nextScrollLeft,\n      nextScrollTop: nextScrollTop\n    };\n  };\n\n  Table.prototype.componentDidUpdate = function (prevProps, prevState, snapshot) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState, snapshot);\n\n    var didChildrenChange = React.Children.toArray(this.props.children) !== this.state.childrenArray;\n    var shouldInvalidateGrid = didChildrenChange || this.props.columnWidths !== prevState.columnWidths || this.props.rowHeights !== prevState.rowHeights || this.props.numRows !== prevProps.numRows || this.props.forceRerenderOnSelectionChange && this.props.selectedRegions !== prevProps.selectedRegions;\n\n    if (shouldInvalidateGrid) {\n      this.invalidateGrid();\n    }\n\n    if (this.locator != null) {\n      this.validateGrid();\n      this.updateLocator();\n    } // When true, we'll need to imperatively synchronize quadrant views after\n    // the update. This check lets us avoid expensively diff'ing columnWidths\n    // and rowHeights in <TableQuadrantStack> on each update.\n\n\n    var didUpdateColumnOrRowSizes = !CoreUtils.arraysEqual(this.state.columnWidths, prevState.columnWidths) || !CoreUtils.arraysEqual(this.state.rowHeights, prevState.rowHeights);\n\n    if (didUpdateColumnOrRowSizes) {\n      this.quadrantStackInstance.synchronizeQuadrantViews();\n      this.syncViewportPosition(snapshot);\n    }\n  };\n\n  Table.prototype.validateProps = function (props) {\n    var children = props.children,\n        columnWidths = props.columnWidths,\n        numFrozenColumns = props.numFrozenColumns,\n        numFrozenRows = props.numFrozenRows,\n        numRows = props.numRows,\n        rowHeights = props.rowHeights;\n    var numColumns = React.Children.count(children); // do cheap error-checking first.\n\n    if (numRows != null && numRows < 0) {\n      throw new Error(Errors.TABLE_NUM_ROWS_NEGATIVE);\n    }\n\n    if (numFrozenRows != null && numFrozenRows < 0) {\n      throw new Error(Errors.TABLE_NUM_FROZEN_ROWS_NEGATIVE);\n    }\n\n    if (numFrozenColumns != null && numFrozenColumns < 0) {\n      throw new Error(Errors.TABLE_NUM_FROZEN_COLUMNS_NEGATIVE);\n    }\n\n    if (numRows != null && rowHeights != null && rowHeights.length !== numRows) {\n      throw new Error(Errors.TABLE_NUM_ROWS_ROW_HEIGHTS_MISMATCH);\n    }\n\n    if (numColumns != null && columnWidths != null && columnWidths.length !== numColumns) {\n      throw new Error(Errors.TABLE_NUM_COLUMNS_COLUMN_WIDTHS_MISMATCH);\n    }\n\n    React.Children.forEach(children, function (child) {\n      if (!CoreUtils.isElementOfType(child, Column)) {\n        throw new Error(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);\n      }\n    }); // these are recoverable scenarios, so just print a warning.\n\n    if (numFrozenRows != null && numRows != null && numFrozenRows > numRows) {\n      console.warn(Errors.TABLE_NUM_FROZEN_ROWS_BOUND_WARNING);\n    }\n\n    if (numFrozenColumns != null && numFrozenColumns > numColumns) {\n      console.warn(Errors.TABLE_NUM_FROZEN_COLUMNS_BOUND_WARNING);\n    }\n  };\n\n  Table.prototype.gridDimensionsMatchProps = function () {\n    var _a = this.props,\n        children = _a.children,\n        numRows = _a.numRows;\n    return this.grid != null && this.grid.numCols === React.Children.count(children) && this.grid.numRows === numRows;\n  }; // Hotkeys\n  // =======\n\n\n  Table.prototype.maybeRenderCopyHotkey = function () {\n    var getCellClipboardData = this.props.getCellClipboardData;\n\n    if (getCellClipboardData != null) {\n      return React.createElement(Hotkey, {\n        key: \"copy-hotkey\",\n        label: \"Copy selected table cells\",\n        group: \"Table\",\n        combo: \"mod+c\",\n        onKeyDown: this.handleCopy\n      });\n    } else {\n      return undefined;\n    }\n  };\n\n  Table.prototype.maybeRenderSelectionResizeHotkeys = function () {\n    var _a = this.props,\n        enableMultipleSelection = _a.enableMultipleSelection,\n        selectionModes = _a.selectionModes;\n    var isSomeSelectionModeEnabled = selectionModes.length > 0;\n\n    if (enableMultipleSelection && isSomeSelectionModeEnabled) {\n      return [React.createElement(Hotkey, {\n        key: \"resize-selection-up\",\n        label: \"Resize selection upward\",\n        group: \"Table\",\n        combo: \"shift+up\",\n        onKeyDown: this.handleSelectionResizeUp\n      }), React.createElement(Hotkey, {\n        key: \"resize-selection-down\",\n        label: \"Resize selection downward\",\n        group: \"Table\",\n        combo: \"shift+down\",\n        onKeyDown: this.handleSelectionResizeDown\n      }), React.createElement(Hotkey, {\n        key: \"resize-selection-left\",\n        label: \"Resize selection leftward\",\n        group: \"Table\",\n        combo: \"shift+left\",\n        onKeyDown: this.handleSelectionResizeLeft\n      }), React.createElement(Hotkey, {\n        key: \"resize-selection-right\",\n        label: \"Resize selection rightward\",\n        group: \"Table\",\n        combo: \"shift+right\",\n        onKeyDown: this.handleSelectionResizeRight\n      })];\n    } else {\n      return undefined;\n    }\n  };\n\n  Table.prototype.maybeRenderFocusHotkeys = function () {\n    var enableFocusedCell = this.props.enableFocusedCell;\n\n    if (enableFocusedCell != null) {\n      return [React.createElement(Hotkey, {\n        key: \"move left\",\n        label: \"Move focus cell left\",\n        group: \"Table\",\n        combo: \"left\",\n        onKeyDown: this.handleFocusMoveLeft\n      }), React.createElement(Hotkey, {\n        key: \"move right\",\n        label: \"Move focus cell right\",\n        group: \"Table\",\n        combo: \"right\",\n        onKeyDown: this.handleFocusMoveRight\n      }), React.createElement(Hotkey, {\n        key: \"move up\",\n        label: \"Move focus cell up\",\n        group: \"Table\",\n        combo: \"up\",\n        onKeyDown: this.handleFocusMoveUp\n      }), React.createElement(Hotkey, {\n        key: \"move down\",\n        label: \"Move focus cell down\",\n        group: \"Table\",\n        combo: \"down\",\n        onKeyDown: this.handleFocusMoveDown\n      }), React.createElement(Hotkey, {\n        key: \"move tab\",\n        label: \"Move focus cell tab\",\n        group: \"Table\",\n        combo: \"tab\",\n        onKeyDown: this.handleFocusMoveRightInternal,\n        allowInInput: true\n      }), React.createElement(Hotkey, {\n        key: \"move shift-tab\",\n        label: \"Move focus cell shift tab\",\n        group: \"Table\",\n        combo: \"shift+tab\",\n        onKeyDown: this.handleFocusMoveLeftInternal,\n        allowInInput: true\n      }), React.createElement(Hotkey, {\n        key: \"move enter\",\n        label: \"Move focus cell enter\",\n        group: \"Table\",\n        combo: \"enter\",\n        onKeyDown: this.handleFocusMoveDownInternal,\n        allowInInput: true\n      }), React.createElement(Hotkey, {\n        key: \"move shift-enter\",\n        label: \"Move focus cell shift enter\",\n        group: \"Table\",\n        combo: \"shift+enter\",\n        onKeyDown: this.handleFocusMoveUpInternal,\n        allowInInput: true\n      })];\n    } else {\n      return [];\n    }\n  };\n\n  Table.prototype.maybeRenderSelectAllHotkey = function () {\n    if (Table_1.isSelectionModeEnabled(this.props, RegionCardinality.FULL_TABLE)) {\n      return React.createElement(Hotkey, {\n        key: \"select-all-hotkey\",\n        label: \"Select all\",\n        group: \"Table\",\n        combo: \"mod+a\",\n        onKeyDown: this.handleSelectAllHotkey\n      });\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Replaces the selected region at the specified array index, with the\n   * region provided.\n   */\n\n\n  Table.prototype.updateSelectedRegionAtIndex = function (region, index) {\n    var _a = this.props,\n        children = _a.children,\n        numRows = _a.numRows;\n    var selectedRegions = this.state.selectedRegions;\n    var numColumns = React.Children.count(children);\n    var maxRowIndex = Math.max(0, numRows - 1);\n    var maxColumnIndex = Math.max(0, numColumns - 1);\n    var clampedNextRegion = Regions.clampRegion(region, maxRowIndex, maxColumnIndex);\n    var nextSelectedRegions = Regions.update(selectedRegions, clampedNextRegion, index);\n    this.handleSelection(nextSelectedRegions);\n  }; // Quadrant refs\n  // =============\n\n\n  Table.prototype.moveFocusCell = function (primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {\n    var selectedRegions = this.state.selectedRegions;\n    var primaryAxisPlural = primaryAxis === \"row\" ? \"rows\" : \"cols\";\n    var secondaryAxisPlural = secondaryAxis === \"row\" ? \"rows\" : \"cols\";\n    var movementDirection = isUpOrLeft ? -1 : +1;\n    var regionIntervalIndex = isUpOrLeft ? 1 : 0; // try moving the cell in the direction along the primary axis\n\n    newFocusedCell[primaryAxis] += movementDirection;\n    var isPrimaryIndexOutOfBounds = isUpOrLeft ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0] : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];\n\n    if (isPrimaryIndexOutOfBounds) {\n      // if we moved outside the bounds of selection region,\n      // move to the start (or end) of the primary axis, and move one along the secondary\n      newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];\n      newFocusedCell[secondaryAxis] += movementDirection;\n      var isSecondaryIndexOutOfBounds = isUpOrLeft ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0] : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];\n\n      if (isSecondaryIndexOutOfBounds) {\n        // if moving along the secondary also moves us outside\n        // go to the start (or end) of the next (or previous region)\n        // (note that if there's only one region you'll be moving to the opposite corner, which is fine)\n        var newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection; // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around\n\n        if (isUpOrLeft ? newFocusCellSelectionIndex < 0 : newFocusCellSelectionIndex >= selectedRegions.length) {\n          newFocusCellSelectionIndex = isUpOrLeft ? selectedRegions.length - 1 : 0;\n        }\n\n        var newFocusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], this.grid.numRows, this.grid.numCols);\n        newFocusedCell = {\n          col: newFocusCellRegion.cols[regionIntervalIndex],\n          focusSelectionIndex: newFocusCellSelectionIndex,\n          row: newFocusCellRegion.rows[regionIntervalIndex]\n        };\n      }\n    }\n\n    return newFocusedCell;\n  };\n\n  Table.prototype.shouldDisableVerticalScroll = function () {\n    var enableGhostCells = this.props.enableGhostCells;\n    var viewportRect = this.state.viewportRect;\n    var rowIndices = this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n    var isViewportUnscrolledVertically = viewportRect != null && viewportRect.top === 0;\n    var areRowHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.ROW_HEADERS);\n    var areGhostRowsVisible = enableGhostCells && this.grid.isGhostIndex(rowIndices.rowIndexEnd, 0);\n    return areGhostRowsVisible && (isViewportUnscrolledVertically || areRowHeadersLoading);\n  };\n\n  Table.prototype.shouldDisableHorizontalScroll = function () {\n    var enableGhostCells = this.props.enableGhostCells;\n    var viewportRect = this.state.viewportRect;\n    var columnIndices = this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);\n    var isViewportUnscrolledHorizontally = viewportRect != null && viewportRect.left === 0;\n    var areGhostColumnsVisible = enableGhostCells && this.grid.isGhostColumn(columnIndices.columnIndexEnd);\n    var areColumnHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.COLUMN_HEADERS);\n    return areGhostColumnsVisible && (isViewportUnscrolledHorizontally || areColumnHeadersLoading);\n  };\n\n  Table.prototype.getColumnProps = function (columnIndex) {\n    var column = this.state.childrenArray[columnIndex];\n    return column === undefined ? undefined : column.props;\n  };\n\n  Table.prototype.isGuidesShowing = function () {\n    return this.state.verticalGuides != null || this.state.horizontalGuides != null;\n  };\n\n  Table.prototype.getEnabledSelectionHandler = function (selectionMode) {\n    if (!Table_1.isSelectionModeEnabled(this.props, selectionMode)) {\n      // If the selection mode isn't enabled, return a callback that\n      // will clear the selection. For example, if row selection is\n      // disabled, clicking on the row header will clear the table's\n      // selection. If all selection modes are enabled, clicking on the\n      // same region twice will clear the selection.\n      return this.clearSelection;\n    } else {\n      return this.handleSelection;\n    }\n  };\n\n  Table.prototype.invalidateGrid = function () {\n    this.grid = null;\n  };\n\n  Table.prototype.validateGrid = function () {\n    if (this.grid == null) {\n      var _a = this.props,\n          defaultRowHeight = _a.defaultRowHeight,\n          defaultColumnWidth = _a.defaultColumnWidth;\n      var _b = this.state,\n          rowHeights = _b.rowHeights,\n          columnWidths = _b.columnWidths;\n      this.grid = new Grid(rowHeights, columnWidths, Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);\n      this.invokeOnVisibleCellsChangeCallback(this.state.viewportRect);\n    }\n  };\n  /**\n   * Renders a `RegionLayer`, applying styles to the regions using the\n   * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so\n   * the `IRegionStyler` should be a new instance on every render if we\n   * intend to redraw the region layer.\n   */\n\n\n  Table.prototype.maybeRenderRegions = function (getRegionStyle, quadrantType) {\n    if (this.isGuidesShowing() && !this.state.isReordering) {\n      // we want to show guides *and* the selection styles when reordering rows or columns\n      return undefined;\n    }\n\n    var regionGroups = Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);\n    return regionGroups.map(function (regionGroup, index) {\n      var regionStyles = regionGroup.regions.map(function (region) {\n        return getRegionStyle(region, quadrantType);\n      });\n      return React.createElement(RegionLayer, {\n        className: classNames(regionGroup.className),\n        key: index,\n        regions: regionGroup.regions,\n        regionStyles: regionStyles\n      });\n    });\n  };\n\n  Table.prototype.syncViewportPosition = function (_a) {\n    var nextScrollLeft = _a.nextScrollLeft,\n        nextScrollTop = _a.nextScrollTop;\n    var viewportRect = this.state.viewportRect;\n\n    if (nextScrollLeft !== undefined || nextScrollTop !== undefined) {\n      // we need to modify the scroll container explicitly for the viewport to shift. in so\n      // doing, we add the size of the header elements, which are not technically part of the\n      // \"grid\" concept (the grid only consists of body cells at present).\n      if (nextScrollTop !== undefined) {\n        var topCorrection = this.shouldDisableVerticalScroll() ? 0 : this.columnHeaderElement.clientHeight;\n        this.scrollContainerElement.scrollTop = nextScrollTop + topCorrection;\n      }\n\n      if (nextScrollLeft !== undefined) {\n        var leftCorrection = this.shouldDisableHorizontalScroll() || this.rowHeaderElement == null ? 0 : this.rowHeaderElement.clientWidth;\n        this.scrollContainerElement.scrollLeft = nextScrollLeft + leftCorrection;\n      }\n\n      var nextViewportRect = new Rect(nextScrollLeft, nextScrollTop, viewportRect.width, viewportRect.height);\n      this.updateViewportRect(nextViewportRect);\n    }\n  };\n\n  Table.prototype.updateLocator = function () {\n    this.locator.setGrid(this.grid).setNumFrozenRows(this.state.numFrozenRowsClamped).setNumFrozenColumns(this.state.numFrozenColumnsClamped);\n  };\n\n  Table.prototype.invokeOnVisibleCellsChangeCallback = function (viewportRect) {\n    var _a, _b;\n\n    var columnIndices = this.grid.getColumnIndicesInRect(viewportRect);\n    var rowIndices = this.grid.getRowIndicesInRect(viewportRect);\n    (_b = (_a = this.props).onVisibleCellsChange) === null || _b === void 0 ? void 0 : _b.call(_a, rowIndices, columnIndices);\n  };\n  /**\n   * Normalizes RenderMode.BATCH_ON_UPDATE into RenderMode.{BATCH,NONE}. We do\n   * this because there are actually multiple updates required before the\n   * <Table> is considered fully \"mounted,\" and adding that knowledge to child\n   * components would lead to tight coupling. Thus, keep it simple for them.\n   */\n\n\n  Table.prototype.getNormalizedRenderMode = function () {\n    var renderMode = this.props.renderMode;\n    var shouldBatchRender = renderMode === RenderMode.BATCH || renderMode === RenderMode.BATCH_ON_UPDATE && this.didCompletelyMount;\n    return shouldBatchRender ? RenderMode.BATCH : RenderMode.NONE;\n  };\n  /**\n   * Returns an object with option keys mapped to their resolved values\n   * (falling back to default values as necessary).\n   */\n\n\n  Table.prototype.resolveResizeRowsByApproximateHeightOptions = function (options, rowIndex, columnIndex) {\n    var optionKeys = Object.keys(Table_1.resizeRowsByApproximateHeightDefaults);\n\n    var optionReducer = function (agg, key) {\n      var valueOrMapper = options === null || options === void 0 ? void 0 : options[key];\n\n      if (typeof valueOrMapper === \"function\") {\n        agg[key] = valueOrMapper(rowIndex, columnIndex);\n      } else if (valueOrMapper != null) {\n        agg[key] = valueOrMapper;\n      } else {\n        agg[key] = Table_1.resizeRowsByApproximateHeightDefaults[key];\n      }\n\n      return agg;\n    };\n\n    var resolvedOptions = optionKeys.reduce(optionReducer, {});\n    return resolvedOptions;\n  };\n\n  var Table_1;\n  Table.displayName = DISPLAYNAME_PREFIX + \".Table\";\n  Table.defaultProps = {\n    defaultColumnWidth: 150,\n    defaultRowHeight: 20,\n    enableFocusedCell: false,\n    enableGhostCells: false,\n    enableMultipleSelection: true,\n    enableRowHeader: true,\n    forceRerenderOnSelectionChange: false,\n    loadingOptions: [],\n    minColumnWidth: 50,\n    minRowHeight: 20,\n    numFrozenColumns: 0,\n    numFrozenRows: 0,\n    numRows: 0,\n    renderMode: RenderMode.BATCH_ON_UPDATE,\n    rowHeaderCellRenderer: renderDefaultRowHeader,\n    selectionModes: SelectionModes.ALL\n  };\n  Table.childContextTypes = columnInteractionBarContextTypes; // these default values for `resizeRowsByApproximateHeight` have been\n  // fine-tuned to work well with default Table font styles.\n\n  Table.resizeRowsByApproximateHeightDefaults = {\n    getApproximateCharWidth: 8,\n    getApproximateLineHeight: 18,\n    getCellHorizontalPadding: 2 * Locator.CELL_HORIZONTAL_PADDING,\n    getNumBufferLines: 1\n  };\n  Table.SHALLOW_COMPARE_PROP_KEYS_DENYLIST = [\"selectedRegions\"];\n  Table.SHALLOW_COMPARE_STATE_KEYS_DENYLIST = [\"selectedRegions\", \"viewportRect\"];\n  Table = Table_1 = __decorate([HotkeysTarget, polyfill], Table);\n  return Table;\n}(AbstractComponent2);\n\nexport { Table };\n\nfunction clampNumFrozenColumns(props) {\n  var numFrozenColumns = props.numFrozenColumns;\n  var numColumns = React.Children.count(props.children);\n  return clampPotentiallyNullValue(numFrozenColumns, numColumns);\n}\n\nfunction clampNumFrozenRows(props) {\n  var numFrozenRows = props.numFrozenRows,\n      numRows = props.numRows;\n  return clampPotentiallyNullValue(numFrozenRows, numRows);\n} // add explicit `| null | undefined`, because the params make more sense in this\n// order, and you can't have an optional param precede a required param.\n\n\nfunction clampPotentiallyNullValue(value, max) {\n  return value == null ? 0 : Utils.clamp(value, 0, max);\n}","map":{"version":3,"sources":["../../src/table.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Hotkey, Hotkeys, HotkeysTarget, Utils as CoreUtils, } from \"@blueprintjs/core\";\nimport { Column } from \"./column\";\nimport * as Classes from \"./common/classes\";\nimport { Clipboard } from \"./common/clipboard\";\nimport { columnInteractionBarContextTypes } from \"./common/context\";\nimport { Direction } from \"./common/direction\";\nimport * as Errors from \"./common/errors\";\nimport { Grid } from \"./common/grid\";\nimport * as FocusedCellUtils from \"./common/internal/focusedCellUtils\";\nimport * as ScrollUtils from \"./common/internal/scrollUtils\";\nimport * as SelectionUtils from \"./common/internal/selectionUtils\";\nimport { Rect } from \"./common/rect\";\nimport { RenderMode } from \"./common/renderMode\";\nimport { Utils } from \"./common/utils\";\nimport { ColumnHeader } from \"./headers/columnHeader\";\nimport { ColumnHeaderCell } from \"./headers/columnHeaderCell\";\nimport { renderDefaultRowHeader, RowHeader } from \"./headers/rowHeader\";\nimport { ResizeSensor } from \"./interactions/resizeSensor\";\nimport { GuideLayer } from \"./layers/guides\";\nimport { RegionLayer } from \"./layers/regions\";\nimport { Locator } from \"./locator\";\nimport { QuadrantType } from \"./quadrants/tableQuadrant\";\nimport { TableQuadrantStack } from \"./quadrants/tableQuadrantStack\";\nimport { ColumnLoadingOption, RegionCardinality, Regions, SelectionModes, TableLoadingOption, } from \"./regions\";\nimport { TableBody } from \"./tableBody\";\n// HACKHACK(adahiya): fix for Blueprint 4.0\n// eslint-disable-next-line deprecation/deprecation\nvar Table = /** @class */ (function (_super) {\n    __extends(Table, _super);\n    function Table(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.refHandlers = {\n            cellContainer: function (ref) { return (_this.cellContainerElement = ref); },\n            columnHeader: function (ref) { return (_this.columnHeaderElement = ref); },\n            quadrantStack: function (ref) { return (_this.quadrantStackInstance = ref); },\n            rootTable: function (ref) { return (_this.rootTableElement = ref); },\n            rowHeader: function (ref) { return (_this.rowHeaderElement = ref); },\n            scrollContainer: function (ref) { return (_this.scrollContainerElement = ref); },\n        };\n        /*\n         * This value is set to `true` when all cells finish mounting for the first\n         * time. It serves as a signal that we can switch to batch rendering.\n         */\n        _this.didCompletelyMount = false;\n        // Selection resize\n        // ----------------\n        _this.handleSelectionResizeUp = function (e) { return _this.handleSelectionResize(e, Direction.UP); };\n        _this.handleSelectionResizeDown = function (e) { return _this.handleSelectionResize(e, Direction.DOWN); };\n        _this.handleSelectionResizeLeft = function (e) { return _this.handleSelectionResize(e, Direction.LEFT); };\n        _this.handleSelectionResizeRight = function (e) { return _this.handleSelectionResize(e, Direction.RIGHT); };\n        _this.handleSelectionResize = function (e, direction) {\n            e.preventDefault();\n            e.stopPropagation();\n            var _a = _this.state, focusedCell = _a.focusedCell, selectedRegions = _a.selectedRegions;\n            if (selectedRegions.length === 0) {\n                return;\n            }\n            var index = FocusedCellUtils.getFocusedOrLastSelectedIndex(selectedRegions, focusedCell);\n            var region = selectedRegions[index];\n            var nextRegion = SelectionUtils.resizeRegion(region, direction, focusedCell);\n            _this.updateSelectedRegionAtIndex(nextRegion, index);\n        };\n        _this.handleCopy = function (e) {\n            var _a = _this.props, getCellClipboardData = _a.getCellClipboardData, onCopy = _a.onCopy;\n            var selectedRegions = _this.state.selectedRegions;\n            if (getCellClipboardData == null) {\n                return;\n            }\n            // prevent \"real\" copy from being called\n            e.preventDefault();\n            e.stopPropagation();\n            var cells = Regions.enumerateUniqueCells(selectedRegions, _this.grid.numRows, _this.grid.numCols);\n            var sparse = Regions.sparseMapCells(cells, getCellClipboardData);\n            if (sparse != null) {\n                var success = Clipboard.copyCells(sparse);\n                onCopy === null || onCopy === void 0 ? void 0 : onCopy(success);\n            }\n        };\n        _this.renderMenu = function (refHandler) {\n            var _a;\n            var classes = classNames(Classes.TABLE_MENU, (_a = {},\n                _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_TABLE),\n                _a));\n            return (React.createElement(\"div\", { className: classes, ref: refHandler, onMouseDown: _this.handleMenuMouseDown }, _this.maybeRenderRegions(_this.styleMenuRegion)));\n        };\n        _this.handleMenuMouseDown = function (e) {\n            // the shift+click interaction expands the region from the focused cell.\n            // thus, if shift is pressed we shouldn't move the focused cell.\n            _this.selectAll(!e.shiftKey);\n        };\n        _this.selectAll = function (shouldUpdateFocusedCell) {\n            var selectionHandler = _this.getEnabledSelectionHandler(RegionCardinality.FULL_TABLE);\n            // clicking on upper left hand corner sets selection to \"all\"\n            // regardless of current selection state (clicking twice does not deselect table)\n            selectionHandler([Regions.table()]);\n            if (shouldUpdateFocusedCell) {\n                var newFocusedCellCoordinates = Regions.getFocusCellCoordinatesFromRegion(Regions.table());\n                _this.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));\n            }\n        };\n        _this.handleSelectAllHotkey = function (e) {\n            // prevent \"real\" select all from happening as well\n            e.preventDefault();\n            e.stopPropagation();\n            // selecting-all via the keyboard should not move the focused cell.\n            _this.selectAll(false);\n        };\n        _this.columnHeaderCellRenderer = function (columnIndex) {\n            var props = _this.getColumnProps(columnIndex);\n            if (props === undefined) {\n                return null;\n            }\n            var id = props.id, loadingOptions = props.loadingOptions, cellRenderer = props.cellRenderer, columnHeaderCellRenderer = props.columnHeaderCellRenderer, spreadableProps = __rest(props, [\"id\", \"loadingOptions\", \"cellRenderer\", \"columnHeaderCellRenderer\"]);\n            var columnLoading = _this.hasLoadingOption(loadingOptions, ColumnLoadingOption.HEADER);\n            if (columnHeaderCellRenderer != null) {\n                var columnHeaderCell = columnHeaderCellRenderer(columnIndex);\n                var columnHeaderCellLoading = columnHeaderCell.props.loading;\n                var columnHeaderCellProps = {\n                    loading: columnHeaderCellLoading != null ? columnHeaderCellLoading : columnLoading,\n                };\n                return React.cloneElement(columnHeaderCell, columnHeaderCellProps);\n            }\n            var baseProps = __assign({ index: columnIndex, loading: columnLoading }, spreadableProps);\n            if (props.name != null) {\n                return React.createElement(ColumnHeaderCell, __assign({}, baseProps));\n            }\n            else {\n                return React.createElement(ColumnHeaderCell, __assign({}, baseProps, { name: Utils.toBase26Alpha(columnIndex) }));\n            }\n        };\n        _this.renderColumnHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly) {\n            var _a;\n            if (showFrozenColumnsOnly === void 0) { showFrozenColumnsOnly = false; }\n            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;\n            var _c = _this.props, enableMultipleSelection = _c.enableMultipleSelection, enableGhostCells = _c.enableGhostCells, enableColumnReordering = _c.enableColumnReordering, enableColumnResizing = _c.enableColumnResizing, loadingOptions = _c.loadingOptions, maxColumnWidth = _c.maxColumnWidth, minColumnWidth = _c.minColumnWidth, selectedRegionTransform = _c.selectedRegionTransform;\n            var classes = classNames(Classes.TABLE_COLUMN_HEADERS, (_a = {},\n                _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_COLUMNS),\n                _a));\n            var columnIndices = _this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);\n            var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;\n            var columnIndexEnd = showFrozenColumnsOnly ? _this.getMaxFrozenColumnIndex() : columnIndices.columnIndexEnd;\n            return (React.createElement(\"div\", { className: classes },\n                React.createElement(ColumnHeader, { enableMultipleSelection: enableMultipleSelection, cellRenderer: _this.columnHeaderCellRenderer, focusedCell: focusedCell, grid: _this.grid, isReorderable: enableColumnReordering, isResizable: enableColumnResizing, loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.COLUMN_HEADERS), locator: _this.locator, maxColumnWidth: maxColumnWidth, measurableElementRef: refHandler, minColumnWidth: minColumnWidth, onColumnWidthChanged: _this.handleColumnWidthChanged, onFocusedCell: _this.handleFocus, onLayoutLock: _this.handleLayoutLock, onReordered: _this.handleColumnsReordered, onReordering: reorderingHandler, onResizeGuide: resizeHandler, onSelection: _this.getEnabledSelectionHandler(RegionCardinality.FULL_COLUMNS), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd }, _this.props.children),\n                _this.maybeRenderRegions(_this.styleColumnHeaderRegion)));\n        };\n        _this.renderRowHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly) {\n            var _a;\n            if (showFrozenRowsOnly === void 0) { showFrozenRowsOnly = false; }\n            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;\n            var _c = _this.props, enableMultipleSelection = _c.enableMultipleSelection, enableGhostCells = _c.enableGhostCells, enableRowReordering = _c.enableRowReordering, enableRowResizing = _c.enableRowResizing, loadingOptions = _c.loadingOptions, maxRowHeight = _c.maxRowHeight, minRowHeight = _c.minRowHeight, rowHeaderCellRenderer = _c.rowHeaderCellRenderer, selectedRegionTransform = _c.selectedRegionTransform;\n            var classes = classNames(Classes.TABLE_ROW_HEADERS, (_a = {},\n                _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_ROWS),\n                _a));\n            var rowIndices = _this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n            var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;\n            var rowIndexEnd = showFrozenRowsOnly ? _this.getMaxFrozenRowIndex() : rowIndices.rowIndexEnd;\n            return (React.createElement(\"div\", { className: classes, ref: refHandler },\n                React.createElement(RowHeader, { enableMultipleSelection: enableMultipleSelection, focusedCell: focusedCell, grid: _this.grid, locator: _this.locator, isReorderable: enableRowReordering, isResizable: enableRowResizing, loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.ROW_HEADERS), maxRowHeight: maxRowHeight, minRowHeight: minRowHeight, onFocusedCell: _this.handleFocus, onLayoutLock: _this.handleLayoutLock, onResizeGuide: resizeHandler, onReordered: _this.handleRowsReordered, onReordering: reorderingHandler, onRowHeightChanged: _this.handleRowHeightChanged, onSelection: _this.getEnabledSelectionHandler(RegionCardinality.FULL_ROWS), rowHeaderCellRenderer: rowHeaderCellRenderer, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd }),\n                _this.maybeRenderRegions(_this.styleRowHeaderRegion)));\n        };\n        _this.bodyCellRenderer = function (rowIndex, columnIndex) {\n            var columnProps = _this.getColumnProps(columnIndex);\n            if (columnProps === undefined) {\n                return null;\n            }\n            var id = columnProps.id, loadingOptions = columnProps.loadingOptions, cellRenderer = columnProps.cellRenderer, columnHeaderCellRenderer = columnProps.columnHeaderCellRenderer, name = columnProps.name, nameRenderer = columnProps.nameRenderer, restColumnProps = __rest(columnProps, [\"id\", \"loadingOptions\", \"cellRenderer\", \"columnHeaderCellRenderer\", \"name\", \"nameRenderer\"]);\n            var cell = cellRenderer(rowIndex, columnIndex);\n            var _a = cell.props.loading, loading = _a === void 0 ? _this.hasLoadingOption(loadingOptions, ColumnLoadingOption.CELLS) : _a;\n            var cellProps = __assign(__assign({}, restColumnProps), { loading: loading });\n            return React.cloneElement(cell, cellProps);\n        };\n        _this.renderBody = function (quadrantType, showFrozenRowsOnly, showFrozenColumnsOnly) {\n            if (showFrozenRowsOnly === void 0) { showFrozenRowsOnly = false; }\n            if (showFrozenColumnsOnly === void 0) { showFrozenColumnsOnly = false; }\n            var _a = _this.state, focusedCell = _a.focusedCell, numFrozenColumns = _a.numFrozenColumnsClamped, numFrozenRows = _a.numFrozenRowsClamped, selectedRegions = _a.selectedRegions, viewportRect = _a.viewportRect;\n            var _b = _this.props, enableMultipleSelection = _b.enableMultipleSelection, enableGhostCells = _b.enableGhostCells, loadingOptions = _b.loadingOptions, bodyContextMenuRenderer = _b.bodyContextMenuRenderer, selectedRegionTransform = _b.selectedRegionTransform;\n            var rowIndices = _this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n            var columnIndices = _this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);\n            // start beyond the frozen area if rendering unrelated quadrants, so we\n            // don't render duplicate cells underneath the frozen ones.\n            var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart + numFrozenColumns;\n            var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart + numFrozenRows;\n            // if rendering frozen rows/columns, subtract one to convert to\n            // 0-indexing. if the 1-indexed value is 0, this sets the end index\n            // to -1, which avoids rendering absent frozen rows/columns at all.\n            var columnIndexEnd = showFrozenColumnsOnly ? numFrozenColumns - 1 : columnIndices.columnIndexEnd;\n            var rowIndexEnd = showFrozenRowsOnly ? numFrozenRows - 1 : rowIndices.rowIndexEnd;\n            // the main quadrant contains all cells in the table, so listen only to that quadrant\n            var onCompleteRender = quadrantType === QuadrantType.MAIN ? _this.handleCompleteRender : undefined;\n            return (React.createElement(\"div\", null,\n                React.createElement(TableBody, { enableMultipleSelection: enableMultipleSelection, cellRenderer: _this.bodyCellRenderer, focusedCell: focusedCell, grid: _this.grid, loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.CELLS), locator: _this.locator, onCompleteRender: onCompleteRender, onFocusedCell: _this.handleFocus, onSelection: _this.getEnabledSelectionHandler(RegionCardinality.CELLS), bodyContextMenuRenderer: bodyContextMenuRenderer, renderMode: _this.getNormalizedRenderMode(), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd, numFrozenColumns: showFrozenColumnsOnly ? numFrozenColumns : undefined, numFrozenRows: showFrozenRowsOnly ? numFrozenRows : undefined }),\n                _this.maybeRenderRegions(_this.styleBodyRegion, quadrantType)));\n        };\n        _this.handleCompleteRender = function () {\n            var _a, _b;\n            // the first onCompleteRender is triggered before the viewportRect is\n            // defined and the second after the viewportRect has been set. the cells\n            // will only actually render once the viewportRect is defined though, so\n            // we defer invoking onCompleteRender until that check passes.\n            if (_this.state.viewportRect != null) {\n                (_b = (_a = _this.props).onCompleteRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n                _this.didCompletelyMount = true;\n            }\n        };\n        _this.handleFocusMoveLeft = function (e) { return _this.handleFocusMove(e, \"left\"); };\n        _this.handleFocusMoveLeftInternal = function (e) { return _this.handleFocusMoveInternal(e, \"left\"); };\n        _this.handleFocusMoveRight = function (e) { return _this.handleFocusMove(e, \"right\"); };\n        _this.handleFocusMoveRightInternal = function (e) { return _this.handleFocusMoveInternal(e, \"right\"); };\n        _this.handleFocusMoveUp = function (e) { return _this.handleFocusMove(e, \"up\"); };\n        _this.handleFocusMoveUpInternal = function (e) { return _this.handleFocusMoveInternal(e, \"up\"); };\n        _this.handleFocusMoveDown = function (e) { return _this.handleFocusMove(e, \"down\"); };\n        _this.handleFocusMoveDownInternal = function (e) { return _this.handleFocusMoveInternal(e, \"down\"); };\n        _this.styleBodyRegion = function (region, quadrantType) {\n            var numFrozenColumns = _this.props.numFrozenColumns;\n            var cardinality = Regions.getRegionCardinality(region);\n            var style = _this.grid.getRegionStyle(region);\n            // ensure we're not showing borders at the boundary of the frozen-columns area\n            var canHideRightBorder = (quadrantType === QuadrantType.TOP_LEFT || quadrantType === QuadrantType.LEFT) &&\n                numFrozenColumns != null &&\n                numFrozenColumns > 0;\n            var fixedHeight = _this.grid.getHeight();\n            var fixedWidth = _this.grid.getWidth();\n            // include a correction in some cases to hide borders along quadrant boundaries\n            var alignmentCorrection = 1;\n            var alignmentCorrectionString = \"-\" + alignmentCorrection + \"px\";\n            switch (cardinality) {\n                case RegionCardinality.CELLS:\n                    return style;\n                case RegionCardinality.FULL_COLUMNS:\n                    style.top = alignmentCorrectionString;\n                    style.height = fixedHeight + alignmentCorrection;\n                    return style;\n                case RegionCardinality.FULL_ROWS:\n                    style.left = alignmentCorrectionString;\n                    style.width = fixedWidth + alignmentCorrection;\n                    if (canHideRightBorder) {\n                        style.right = alignmentCorrectionString;\n                    }\n                    return style;\n                case RegionCardinality.FULL_TABLE:\n                    style.left = alignmentCorrectionString;\n                    style.top = alignmentCorrectionString;\n                    style.width = fixedWidth + alignmentCorrection;\n                    style.height = fixedHeight + alignmentCorrection;\n                    if (canHideRightBorder) {\n                        style.right = alignmentCorrectionString;\n                    }\n                    return style;\n                default:\n                    return { display: \"none\" };\n            }\n        };\n        _this.styleMenuRegion = function (region) {\n            var viewportRect = _this.state.viewportRect;\n            if (viewportRect == null) {\n                return {};\n            }\n            var cardinality = Regions.getRegionCardinality(region);\n            var style = _this.grid.getRegionStyle(region);\n            switch (cardinality) {\n                case RegionCardinality.FULL_TABLE:\n                    style.right = \"0px\";\n                    style.bottom = \"0px\";\n                    style.top = \"0px\";\n                    style.left = \"0px\";\n                    style.borderBottom = \"none\";\n                    style.borderRight = \"none\";\n                    return style;\n                default:\n                    return { display: \"none\" };\n            }\n        };\n        _this.styleColumnHeaderRegion = function (region) {\n            var viewportRect = _this.state.viewportRect;\n            if (viewportRect == null) {\n                return {};\n            }\n            var cardinality = Regions.getRegionCardinality(region);\n            var style = _this.grid.getRegionStyle(region);\n            switch (cardinality) {\n                case RegionCardinality.FULL_TABLE:\n                    style.left = \"-1px\";\n                    style.borderLeft = \"none\";\n                    style.bottom = \"-1px\";\n                    return style;\n                case RegionCardinality.FULL_COLUMNS:\n                    style.bottom = \"-1px\";\n                    return style;\n                default:\n                    return { display: \"none\" };\n            }\n        };\n        _this.styleRowHeaderRegion = function (region) {\n            var viewportRect = _this.state.viewportRect;\n            if (viewportRect == null) {\n                return {};\n            }\n            var cardinality = Regions.getRegionCardinality(region);\n            var style = _this.grid.getRegionStyle(region);\n            switch (cardinality) {\n                case RegionCardinality.FULL_TABLE:\n                    style.top = \"-1px\";\n                    style.borderTop = \"none\";\n                    style.right = \"-1px\";\n                    return style;\n                case RegionCardinality.FULL_ROWS:\n                    style.right = \"-1px\";\n                    return style;\n                default:\n                    return { display: \"none\" };\n            }\n        };\n        _this.handleColumnWidthChanged = function (columnIndex, width) {\n            var selectedRegions = _this.state.selectedRegions;\n            var columnWidths = _this.state.columnWidths.slice();\n            if (Regions.hasFullTable(selectedRegions)) {\n                for (var col = 0; col < columnWidths.length; col++) {\n                    columnWidths[col] = width;\n                }\n            }\n            if (Regions.hasFullColumn(selectedRegions, columnIndex)) {\n                Regions.eachUniqueFullColumn(selectedRegions, function (col) {\n                    columnWidths[col] = width;\n                });\n            }\n            else {\n                columnWidths[columnIndex] = width;\n            }\n            _this.invalidateGrid();\n            _this.setState({ columnWidths: columnWidths });\n            var onColumnWidthChanged = _this.props.onColumnWidthChanged;\n            if (onColumnWidthChanged != null) {\n                onColumnWidthChanged(columnIndex, width);\n            }\n        };\n        _this.handleRowHeightChanged = function (rowIndex, height) {\n            var selectedRegions = _this.state.selectedRegions;\n            var rowHeights = _this.state.rowHeights.slice();\n            if (Regions.hasFullTable(selectedRegions)) {\n                for (var row = 0; row < rowHeights.length; row++) {\n                    rowHeights[row] = height;\n                }\n            }\n            if (Regions.hasFullRow(selectedRegions, rowIndex)) {\n                Regions.eachUniqueFullRow(selectedRegions, function (row) {\n                    rowHeights[row] = height;\n                });\n            }\n            else {\n                rowHeights[rowIndex] = height;\n            }\n            _this.invalidateGrid();\n            _this.setState({ rowHeights: rowHeights });\n            var onRowHeightChanged = _this.props.onRowHeightChanged;\n            if (onRowHeightChanged != null) {\n                onRowHeightChanged(rowIndex, height);\n            }\n        };\n        _this.handleRootScroll = function (_event) {\n            // Bug #211 - Native browser text selection events can cause the root\n            // element to scroll even though it has a overflow:hidden style. The\n            // only viable solution to this is to unscroll the element after the\n            // browser scrolls it.\n            if (_this.rootTableElement != null) {\n                _this.rootTableElement.scrollLeft = 0;\n                _this.rootTableElement.scrollTop = 0;\n            }\n        };\n        _this.handleBodyScroll = function (event) {\n            // Prevent the event from propagating to avoid a resize event on the\n            // resize sensor.\n            event.stopPropagation();\n            if (_this.locator != null && !_this.state.isLayoutLocked) {\n                var viewportRect = _this.locator.getViewportRect();\n                _this.updateViewportRect(viewportRect);\n            }\n        };\n        _this.clearSelection = function (_selectedRegions) {\n            _this.handleSelection([]);\n        };\n        // no good way to call arrow-key keyboard events from tests\n        /* istanbul ignore next */\n        _this.handleFocusMove = function (e, direction) {\n            e.preventDefault();\n            e.stopPropagation();\n            var focusedCell = _this.state.focusedCell;\n            if (focusedCell == null) {\n                // halt early if we have a selectedRegionTransform or something else in play that nixes\n                // the focused cell.\n                return;\n            }\n            var newFocusedCell = {\n                col: focusedCell.col,\n                focusSelectionIndex: 0,\n                row: focusedCell.row,\n            };\n            switch (direction) {\n                case \"up\":\n                    newFocusedCell.row -= 1;\n                    break;\n                case \"down\":\n                    newFocusedCell.row += 1;\n                    break;\n                case \"left\":\n                    newFocusedCell.col -= 1;\n                    break;\n                case \"right\":\n                    newFocusedCell.col += 1;\n                    break;\n                default:\n                    break;\n            }\n            if (newFocusedCell.row < 0 ||\n                newFocusedCell.row >= _this.grid.numRows ||\n                newFocusedCell.col < 0 ||\n                newFocusedCell.col >= _this.grid.numCols) {\n                return;\n            }\n            // change selection to match new focus cell location\n            var newSelectionRegions = [Regions.cell(newFocusedCell.row, newFocusedCell.col)];\n            var selectedRegionTransform = _this.props.selectedRegionTransform;\n            var transformedSelectionRegions = selectedRegionTransform != null\n                ? newSelectionRegions.map(function (region) { return selectedRegionTransform(region, e); })\n                : newSelectionRegions;\n            _this.handleSelection(transformedSelectionRegions);\n            _this.handleFocus(newFocusedCell);\n            // keep the focused cell in view\n            _this.scrollBodyToFocusedCell(newFocusedCell);\n        };\n        // no good way to call arrow-key keyboard events from tests\n        /* istanbul ignore next */\n        _this.handleFocusMoveInternal = function (e, direction) {\n            e.preventDefault();\n            e.stopPropagation();\n            var _a = _this.state, focusedCell = _a.focusedCell, selectedRegions = _a.selectedRegions;\n            if (focusedCell == null) {\n                // halt early if we have a selectedRegionTransform or something else in play that nixes\n                // the focused cell.\n                return;\n            }\n            var newFocusedCell = {\n                col: focusedCell.col,\n                focusSelectionIndex: focusedCell.focusSelectionIndex,\n                row: focusedCell.row,\n            };\n            // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one\n            if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {\n                var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[0], _this.grid.numRows, _this.grid.numCols);\n                newFocusedCell = {\n                    col: focusCellRegion.cols[0],\n                    focusSelectionIndex: 0,\n                    row: focusCellRegion.rows[0],\n                };\n            }\n            else {\n                if (selectedRegions.length === 0) {\n                    _this.handleFocusMove(e, direction);\n                    return;\n                }\n                var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], _this.grid.numRows, _this.grid.numCols);\n                if (focusCellRegion.cols[0] === focusCellRegion.cols[1] &&\n                    focusCellRegion.rows[0] === focusCellRegion.rows[1] &&\n                    selectedRegions.length === 1) {\n                    _this.handleFocusMove(e, direction);\n                    return;\n                }\n                switch (direction) {\n                    case \"up\":\n                        newFocusedCell = _this.moveFocusCell(\"row\", \"col\", true, newFocusedCell, focusCellRegion);\n                        break;\n                    case \"left\":\n                        newFocusedCell = _this.moveFocusCell(\"col\", \"row\", true, newFocusedCell, focusCellRegion);\n                        break;\n                    case \"down\":\n                        newFocusedCell = _this.moveFocusCell(\"row\", \"col\", false, newFocusedCell, focusCellRegion);\n                        break;\n                    case \"right\":\n                        newFocusedCell = _this.moveFocusCell(\"col\", \"row\", false, newFocusedCell, focusCellRegion);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (newFocusedCell.row < 0 ||\n                newFocusedCell.row >= _this.grid.numRows ||\n                newFocusedCell.col < 0 ||\n                newFocusedCell.col >= _this.grid.numCols) {\n                return;\n            }\n            _this.handleFocus(newFocusedCell);\n            // keep the focused cell in view\n            _this.scrollBodyToFocusedCell(newFocusedCell);\n        };\n        _this.scrollBodyToFocusedCell = function (focusedCell) {\n            var row = focusedCell.row, col = focusedCell.col;\n            var viewportRect = _this.state.viewportRect;\n            // sort keys in normal CSS position order (per the trusty TRBL/\"trouble\" acronym)\n            // tslint:disable:object-literal-sort-keys\n            var viewportBounds = {\n                top: viewportRect.top,\n                right: viewportRect.left + viewportRect.width,\n                bottom: viewportRect.top + viewportRect.height,\n                left: viewportRect.left,\n            };\n            var focusedCellBounds = {\n                top: _this.grid.getCumulativeHeightBefore(row),\n                right: _this.grid.getCumulativeWidthAt(col),\n                bottom: _this.grid.getCumulativeHeightAt(row),\n                left: _this.grid.getCumulativeWidthBefore(col),\n            };\n            // tslint:enable:object-literal-sort-keys\n            var focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;\n            var focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;\n            var isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;\n            var isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;\n            var ss = {};\n            // keep the top end of an overly tall focused cell in view when moving left and right\n            // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)\n            if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {\n                // scroll up (minus one pixel to avoid clipping the focused-cell border)\n                ss.nextScrollTop = Math.max(0, focusedCellBounds.top - 1);\n            }\n            else if (focusedCellBounds.bottom > viewportBounds.bottom) {\n                // scroll down\n                var scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;\n                ss.nextScrollTop = viewportBounds.top + scrollDelta;\n            }\n            // keep the left end of an overly wide focused cell in view when moving up and down\n            if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {\n                // scroll left (again minus one additional pixel)\n                ss.nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);\n            }\n            else if (focusedCellBounds.right > viewportBounds.right) {\n                // scroll right\n                var scrollDelta = focusedCellBounds.right - viewportBounds.right;\n                ss.nextScrollLeft = viewportBounds.left + scrollDelta;\n            }\n            _this.syncViewportPosition(ss);\n        };\n        _this.handleFocus = function (focusedCell) {\n            var _a, _b;\n            if (!_this.props.enableFocusedCell) {\n                // don't set focus state if focus is not allowed\n                return;\n            }\n            // only set focused cell state if not specified in props\n            if (_this.props.focusedCell == null) {\n                _this.setState({ focusedCell: focusedCell });\n            }\n            (_b = (_a = _this.props).onFocusedCell) === null || _b === void 0 ? void 0 : _b.call(_a, focusedCell);\n        };\n        _this.handleSelection = function (selectedRegions) {\n            // only set selectedRegions state if not specified in props\n            if (_this.props.selectedRegions == null) {\n                _this.setState({ selectedRegions: selectedRegions });\n            }\n            var onSelection = _this.props.onSelection;\n            if (onSelection != null) {\n                onSelection(selectedRegions);\n            }\n        };\n        _this.handleColumnsReordering = function (verticalGuides) {\n            _this.setState({ isReordering: true, verticalGuides: verticalGuides });\n        };\n        _this.handleColumnsReordered = function (oldIndex, newIndex, length) {\n            var _a, _b;\n            _this.setState({ isReordering: false, verticalGuides: undefined });\n            (_b = (_a = _this.props).onColumnsReordered) === null || _b === void 0 ? void 0 : _b.call(_a, oldIndex, newIndex, length);\n        };\n        _this.handleRowsReordering = function (horizontalGuides) {\n            _this.setState({ isReordering: true, horizontalGuides: horizontalGuides });\n        };\n        _this.handleRowsReordered = function (oldIndex, newIndex, length) {\n            var _a, _b;\n            _this.setState({ isReordering: false, horizontalGuides: undefined });\n            (_b = (_a = _this.props).onRowsReordered) === null || _b === void 0 ? void 0 : _b.call(_a, oldIndex, newIndex, length);\n        };\n        _this.handleLayoutLock = function (isLayoutLocked) {\n            if (isLayoutLocked === void 0) { isLayoutLocked = false; }\n            _this.setState({ isLayoutLocked: isLayoutLocked });\n        };\n        _this.hasLoadingOption = function (loadingOptions, loadingOption) {\n            if (loadingOptions == null) {\n                return undefined;\n            }\n            return loadingOptions.indexOf(loadingOption) >= 0;\n        };\n        _this.updateViewportRect = function (nextViewportRect) {\n            var viewportRect = _this.state.viewportRect;\n            _this.setState({ viewportRect: nextViewportRect });\n            var didViewportChange = (viewportRect != null && !viewportRect.equals(nextViewportRect)) ||\n                (viewportRect == null && nextViewportRect != null);\n            if (didViewportChange) {\n                _this.invokeOnVisibleCellsChangeCallback(nextViewportRect);\n            }\n        };\n        _this.getMaxFrozenColumnIndex = function () {\n            var numFrozenColumns = _this.state.numFrozenColumnsClamped;\n            return numFrozenColumns != null ? numFrozenColumns - 1 : undefined;\n        };\n        _this.getMaxFrozenRowIndex = function () {\n            var numFrozenRows = _this.state.numFrozenRowsClamped;\n            return numFrozenRows != null ? numFrozenRows - 1 : undefined;\n        };\n        _this.handleColumnResizeGuide = function (verticalGuides) {\n            _this.setState({ verticalGuides: verticalGuides });\n        };\n        _this.handleRowResizeGuide = function (horizontalGuides) {\n            _this.setState({ horizontalGuides: horizontalGuides });\n        };\n        var _a = _this.props, children = _a.children, columnWidths = _a.columnWidths, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth, numRows = _a.numRows, rowHeights = _a.rowHeights;\n        var childrenArray = React.Children.toArray(children);\n        var columnIdToIndex = Table_1.createColumnIdIndex(childrenArray);\n        // Create height/width arrays using the lengths from props and\n        // children, the default values from props, and finally any sparse\n        // arrays passed into props.\n        var newColumnWidths = childrenArray.map(function () { return defaultColumnWidth; });\n        newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);\n        var newRowHeights = Utils.times(numRows, function () { return defaultRowHeight; });\n        newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);\n        var selectedRegions = props.selectedRegions == null ? [] : props.selectedRegions;\n        var focusedCell = FocusedCellUtils.getInitialFocusedCell(props.enableFocusedCell, props.focusedCell, undefined, selectedRegions);\n        _this.state = {\n            childrenArray: childrenArray,\n            columnIdToIndex: columnIdToIndex,\n            columnWidths: newColumnWidths,\n            focusedCell: focusedCell,\n            isLayoutLocked: false,\n            isReordering: false,\n            numFrozenColumnsClamped: clampNumFrozenColumns(props),\n            numFrozenRowsClamped: clampNumFrozenRows(props),\n            rowHeights: newRowHeights,\n            selectedRegions: selectedRegions,\n        };\n        return _this;\n    }\n    Table_1 = Table;\n    Table.getDerivedStateFromProps = function (props, state) {\n        var children = props.children, defaultColumnWidth = props.defaultColumnWidth, defaultRowHeight = props.defaultRowHeight, enableFocusedCell = props.enableFocusedCell, focusedCell = props.focusedCell, numRows = props.numRows, selectedRegions = props.selectedRegions, selectionModes = props.selectionModes;\n        // assign values from state if uncontrolled\n        var columnWidths = props.columnWidths, rowHeights = props.rowHeights;\n        if (columnWidths == null) {\n            columnWidths = state.columnWidths;\n        }\n        if (rowHeights == null) {\n            rowHeights = state.rowHeights;\n        }\n        var newChildrenArray = React.Children.toArray(children);\n        var didChildrenChange = newChildrenArray !== state.childrenArray;\n        var numCols = newChildrenArray.length;\n        var newColumnWidths = columnWidths;\n        if (columnWidths !== state.columnWidths || didChildrenChange) {\n            // Try to maintain widths of columns by looking up the width of the\n            // column that had the same `ID` prop. If none is found, use the\n            // previous width at the same index.\n            var previousColumnWidths = newChildrenArray.map(function (child, index) {\n                var mappedIndex = state.columnIdToIndex[child.props.id];\n                return state.columnWidths[mappedIndex != null ? mappedIndex : index];\n            });\n            // Make sure the width/height arrays have the correct length, but keep\n            // as many existing widths/heights as possible. Also, apply the\n            // sparse width/heights from props.\n            newColumnWidths = Utils.arrayOfLength(newColumnWidths, numCols, defaultColumnWidth);\n            newColumnWidths = Utils.assignSparseValues(newColumnWidths, previousColumnWidths);\n            newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);\n        }\n        var newRowHeights = rowHeights;\n        if (rowHeights !== state.rowHeights || numRows !== state.rowHeights.length) {\n            newRowHeights = Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);\n            newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);\n        }\n        var newSelectedRegions = selectedRegions;\n        if (selectedRegions == null) {\n            // if we're in uncontrolled mode, filter out all selected regions that don't\n            // fit in the current new table dimensions\n            newSelectedRegions = state.selectedRegions.filter(function (region) {\n                var regionCardinality = Regions.getRegionCardinality(region);\n                return (Table_1.isSelectionModeEnabled(props, regionCardinality, selectionModes) &&\n                    Regions.isRegionValidForTable(region, numRows, numCols));\n            });\n        }\n        var newFocusedCell = FocusedCellUtils.getInitialFocusedCell(enableFocusedCell, focusedCell, state.focusedCell, newSelectedRegions);\n        var nextState = {\n            childrenArray: newChildrenArray,\n            columnIdToIndex: didChildrenChange ? Table_1.createColumnIdIndex(newChildrenArray) : state.columnIdToIndex,\n            columnWidths: newColumnWidths,\n            focusedCell: newFocusedCell,\n            numFrozenColumnsClamped: clampNumFrozenColumns(props),\n            numFrozenRowsClamped: clampNumFrozenRows(props),\n            rowHeights: newRowHeights,\n            selectedRegions: newSelectedRegions,\n        };\n        if (!CoreUtils.deepCompareKeys(state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_DENYLIST)) {\n            return nextState;\n        }\n        return null;\n    };\n    Table.createColumnIdIndex = function (children) {\n        var columnIdToIndex = {};\n        for (var i = 0; i < children.length; i++) {\n            var key = children[i].props.id;\n            if (key != null) {\n                columnIdToIndex[String(key)] = i;\n            }\n        }\n        return columnIdToIndex;\n    };\n    Table.isSelectionModeEnabled = function (props, selectionMode, selectionModes) {\n        if (selectionModes === void 0) { selectionModes = props.selectionModes; }\n        var children = props.children, numRows = props.numRows;\n        var numColumns = React.Children.count(children);\n        return selectionModes.indexOf(selectionMode) >= 0 && numRows > 0 && numColumns > 0;\n    };\n    // Instance methods\n    // ================\n    /**\n     * __Experimental!__ Resizes all rows in the table to the approximate\n     * maximum height of wrapped cell content in each row. Works best when each\n     * cell contains plain text of a consistent font style (though font style\n     * may vary between cells). Since this function uses approximate\n     * measurements, results may not be perfect.\n     *\n     * Approximation parameters can be configured for the entire table or on a\n     * per-cell basis. Default values are fine-tuned to work well with default\n     * Table font styles.\n     */\n    Table.prototype.resizeRowsByApproximateHeight = function (getCellText, options) {\n        var numRows = this.props.numRows;\n        var columnWidths = this.state.columnWidths;\n        var numColumns = columnWidths.length;\n        var rowHeights = [];\n        for (var rowIndex = 0; rowIndex < numRows; rowIndex++) {\n            var maxCellHeightInRow = 0;\n            // iterate through each cell in the row\n            for (var columnIndex = 0; columnIndex < numColumns; columnIndex++) {\n                // resolve all parameters to raw values\n                var _a = this.resolveResizeRowsByApproximateHeightOptions(options, rowIndex, columnIndex), approxCharWidth = _a.getApproximateCharWidth, approxLineHeight = _a.getApproximateLineHeight, horizontalPadding = _a.getCellHorizontalPadding, numBufferLines = _a.getNumBufferLines;\n                var cellText = getCellText(rowIndex, columnIndex);\n                var approxCellHeight = Utils.getApproxCellHeight(cellText, columnWidths[columnIndex], approxCharWidth, approxLineHeight, horizontalPadding, numBufferLines);\n                if (approxCellHeight > maxCellHeightInRow) {\n                    maxCellHeightInRow = approxCellHeight;\n                }\n            }\n            rowHeights.push(maxCellHeightInRow);\n        }\n        this.invalidateGrid();\n        this.setState({ rowHeights: rowHeights });\n    };\n    /**\n     * Resize all rows in the table to the height of the tallest visible cell in the specified columns.\n     * If no indices are provided, default to using the tallest visible cell from all columns in view.\n     */\n    Table.prototype.resizeRowsByTallestCell = function (columnIndices) {\n        var _this = this;\n        var tallest = 0;\n        if (columnIndices == null) {\n            // Consider all columns currently in viewport\n            var viewportColumnIndices = this.grid.getColumnIndicesInRect(this.state.viewportRect);\n            for (var col = viewportColumnIndices.columnIndexStart; col <= viewportColumnIndices.columnIndexEnd; col++) {\n                tallest = Math.max(tallest, this.locator.getTallestVisibleCellInColumn(col));\n            }\n        }\n        else {\n            var columnIndicesArray = Array.isArray(columnIndices) ? columnIndices : [columnIndices];\n            var tallestByColumns = columnIndicesArray.map(function (col) { return _this.locator.getTallestVisibleCellInColumn(col); });\n            tallest = Math.max.apply(Math, tallestByColumns);\n        }\n        var rowHeights = Array(this.state.rowHeights.length).fill(tallest);\n        this.invalidateGrid();\n        this.setState({ rowHeights: rowHeights });\n    };\n    /**\n     * Scrolls the table to the target region in a fashion appropriate to the target region's\n     * cardinality:\n     *\n     * - CELLS: Scroll the top-left cell in the target region to the top-left corner of the viewport.\n     * - FULL_ROWS: Scroll the top-most row in the target region to the top of the viewport.\n     * - FULL_COLUMNS: Scroll the left-most column in the target region to the left side of the viewport.\n     * - FULL_TABLE: Scroll the top-left cell in the table to the top-left corner of the viewport.\n     *\n     * If there are active frozen rows and/or columns, the target region will be positioned in the\n     * top-left corner of the non-frozen area (unless the target region itself is in the frozen\n     * area).\n     *\n     * If the target region is close to the bottom-right corner of the table, this function will\n     * simply scroll the target region as close to the top-left as possible until the bottom-right\n     * corner is reached.\n     */\n    Table.prototype.scrollToRegion = function (region) {\n        var _a = this.state, numFrozenColumns = _a.numFrozenColumnsClamped, numFrozenRows = _a.numFrozenRowsClamped;\n        var _b = this.state.viewportRect, currScrollLeft = _b.left, currScrollTop = _b.top;\n        var _c = ScrollUtils.getScrollPositionForRegion(region, currScrollLeft, currScrollTop, this.grid.getCumulativeWidthBefore, this.grid.getCumulativeHeightBefore, numFrozenRows, numFrozenColumns), scrollLeft = _c.scrollLeft, scrollTop = _c.scrollTop;\n        var correctedScrollLeft = this.shouldDisableHorizontalScroll() ? 0 : scrollLeft;\n        var correctedScrollTop = this.shouldDisableVerticalScroll() ? 0 : scrollTop;\n        // defer to the quadrant stack to keep all quadrant positions in sync\n        this.quadrantStackInstance.scrollToPosition(correctedScrollLeft, correctedScrollTop);\n    };\n    // React lifecycle\n    // ===============\n    Table.prototype.getChildContext = function () {\n        return {\n            enableColumnInteractionBar: this.props.enableColumnInteractionBar,\n        };\n    };\n    Table.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n        var propKeysDenylist = { exclude: Table_1.SHALLOW_COMPARE_PROP_KEYS_DENYLIST };\n        var stateKeysDenylist = { exclude: Table_1.SHALLOW_COMPARE_STATE_KEYS_DENYLIST };\n        return (!CoreUtils.shallowCompareKeys(this.props, nextProps, propKeysDenylist) ||\n            !CoreUtils.shallowCompareKeys(this.state, nextState, stateKeysDenylist) ||\n            !CoreUtils.deepCompareKeys(this.props, nextProps, Table_1.SHALLOW_COMPARE_PROP_KEYS_DENYLIST) ||\n            !CoreUtils.deepCompareKeys(this.state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_DENYLIST));\n    };\n    Table.prototype.render = function () {\n        var _a;\n        var _b = this.props, children = _b.children, className = _b.className, enableRowHeader = _b.enableRowHeader, loadingOptions = _b.loadingOptions, numRows = _b.numRows, enableColumnInteractionBar = _b.enableColumnInteractionBar;\n        var _c = this.state, horizontalGuides = _c.horizontalGuides, numFrozenColumnsClamped = _c.numFrozenColumnsClamped, numFrozenRowsClamped = _c.numFrozenRowsClamped, verticalGuides = _c.verticalGuides;\n        if (!this.gridDimensionsMatchProps()) {\n            // Ensure we're rendering the correct number of rows & columns\n            this.invalidateGrid();\n        }\n        this.validateGrid();\n        var classes = classNames(Classes.TABLE_CONTAINER, (_a = {},\n            _a[Classes.TABLE_REORDERING] = this.state.isReordering,\n            _a[Classes.TABLE_NO_VERTICAL_SCROLL] = this.shouldDisableVerticalScroll(),\n            _a[Classes.TABLE_NO_HORIZONTAL_SCROLL] = this.shouldDisableHorizontalScroll(),\n            _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(this.props, RegionCardinality.CELLS),\n            _a[Classes.TABLE_NO_ROWS] = numRows === 0,\n            _a), className);\n        return (React.createElement(\"div\", { className: classes, ref: this.refHandlers.rootTable, onScroll: this.handleRootScroll },\n            React.createElement(TableQuadrantStack, { bodyRef: this.refHandlers.cellContainer, bodyRenderer: this.renderBody, columnHeaderCellRenderer: this.renderColumnHeader, columnHeaderRef: this.refHandlers.columnHeader, enableColumnInteractionBar: enableColumnInteractionBar, enableRowHeader: enableRowHeader, grid: this.grid, handleColumnResizeGuide: this.handleColumnResizeGuide, handleColumnsReordering: this.handleColumnsReordering, handleRowResizeGuide: this.handleRowResizeGuide, handleRowsReordering: this.handleRowsReordering, isHorizontalScrollDisabled: this.shouldDisableHorizontalScroll(), isVerticalScrollDisabled: this.shouldDisableVerticalScroll(), loadingOptions: loadingOptions, numColumns: React.Children.count(children), numFrozenColumns: numFrozenColumnsClamped, numFrozenRows: numFrozenRowsClamped, numRows: numRows, onScroll: this.handleBodyScroll, ref: this.refHandlers.quadrantStack, menuRenderer: this.renderMenu, rowHeaderCellRenderer: this.renderRowHeader, rowHeaderRef: this.refHandlers.rowHeader, scrollContainerRef: this.refHandlers.scrollContainer }),\n            React.createElement(\"div\", { className: classNames(Classes.TABLE_OVERLAY_LAYER, Classes.TABLE_OVERLAY_REORDERING_CURSOR) }),\n            React.createElement(GuideLayer, { className: Classes.TABLE_RESIZE_GUIDES, verticalGuides: verticalGuides, horizontalGuides: horizontalGuides })));\n    };\n    Table.prototype.renderHotkeys = function () {\n        var hotkeys = [\n            this.maybeRenderCopyHotkey(),\n            this.maybeRenderSelectAllHotkey(),\n            this.maybeRenderFocusHotkeys(),\n            this.maybeRenderSelectionResizeHotkeys(),\n        ];\n        return React.createElement(Hotkeys, null, hotkeys.filter(function (element) { return element !== undefined; }));\n    };\n    /**\n     * When the component mounts, the HTML Element refs will be available, so\n     * we constructor the Locator, which queries the elements' bounding\n     * ClientRects.\n     */\n    Table.prototype.componentDidMount = function () {\n        var _this = this;\n        this.validateGrid();\n        this.locator = new Locator(this.rootTableElement, this.scrollContainerElement, this.cellContainerElement);\n        this.updateLocator();\n        this.updateViewportRect(this.locator.getViewportRect());\n        this.resizeSensorDetach = ResizeSensor.attach(this.rootTableElement, function () {\n            if (!_this.state.isLayoutLocked) {\n                _this.updateViewportRect(_this.locator.getViewportRect());\n            }\n        });\n    };\n    Table.prototype.componentWillUnmount = function () {\n        if (this.resizeSensorDetach != null) {\n            this.resizeSensorDetach();\n            delete this.resizeSensorDetach;\n        }\n        this.didCompletelyMount = false;\n    };\n    Table.prototype.getSnapshotBeforeUpdate = function () {\n        var viewportRect = this.state.viewportRect;\n        this.validateGrid();\n        var tableBottom = this.grid.getCumulativeHeightAt(this.grid.numRows - 1);\n        var tableRight = this.grid.getCumulativeWidthAt(this.grid.numCols - 1);\n        var nextScrollTop = tableBottom < viewportRect.top + viewportRect.height\n            ? // scroll the last row into view\n                Math.max(0, tableBottom - viewportRect.height)\n            : undefined;\n        var nextScrollLeft = tableRight < viewportRect.left + viewportRect.width\n            ? // scroll the last column into view\n                Math.max(0, tableRight - viewportRect.width)\n            : undefined;\n        // these will only be defined if they differ from viewportRect\n        return { nextScrollLeft: nextScrollLeft, nextScrollTop: nextScrollTop };\n    };\n    Table.prototype.componentDidUpdate = function (prevProps, prevState, snapshot) {\n        _super.prototype.componentDidUpdate.call(this, prevProps, prevState, snapshot);\n        var didChildrenChange = React.Children.toArray(this.props.children) !==\n            this.state.childrenArray;\n        var shouldInvalidateGrid = didChildrenChange ||\n            this.props.columnWidths !== prevState.columnWidths ||\n            this.props.rowHeights !== prevState.rowHeights ||\n            this.props.numRows !== prevProps.numRows ||\n            (this.props.forceRerenderOnSelectionChange && this.props.selectedRegions !== prevProps.selectedRegions);\n        if (shouldInvalidateGrid) {\n            this.invalidateGrid();\n        }\n        if (this.locator != null) {\n            this.validateGrid();\n            this.updateLocator();\n        }\n        // When true, we'll need to imperatively synchronize quadrant views after\n        // the update. This check lets us avoid expensively diff'ing columnWidths\n        // and rowHeights in <TableQuadrantStack> on each update.\n        var didUpdateColumnOrRowSizes = !CoreUtils.arraysEqual(this.state.columnWidths, prevState.columnWidths) ||\n            !CoreUtils.arraysEqual(this.state.rowHeights, prevState.rowHeights);\n        if (didUpdateColumnOrRowSizes) {\n            this.quadrantStackInstance.synchronizeQuadrantViews();\n            this.syncViewportPosition(snapshot);\n        }\n    };\n    Table.prototype.validateProps = function (props) {\n        var children = props.children, columnWidths = props.columnWidths, numFrozenColumns = props.numFrozenColumns, numFrozenRows = props.numFrozenRows, numRows = props.numRows, rowHeights = props.rowHeights;\n        var numColumns = React.Children.count(children);\n        // do cheap error-checking first.\n        if (numRows != null && numRows < 0) {\n            throw new Error(Errors.TABLE_NUM_ROWS_NEGATIVE);\n        }\n        if (numFrozenRows != null && numFrozenRows < 0) {\n            throw new Error(Errors.TABLE_NUM_FROZEN_ROWS_NEGATIVE);\n        }\n        if (numFrozenColumns != null && numFrozenColumns < 0) {\n            throw new Error(Errors.TABLE_NUM_FROZEN_COLUMNS_NEGATIVE);\n        }\n        if (numRows != null && rowHeights != null && rowHeights.length !== numRows) {\n            throw new Error(Errors.TABLE_NUM_ROWS_ROW_HEIGHTS_MISMATCH);\n        }\n        if (numColumns != null && columnWidths != null && columnWidths.length !== numColumns) {\n            throw new Error(Errors.TABLE_NUM_COLUMNS_COLUMN_WIDTHS_MISMATCH);\n        }\n        React.Children.forEach(children, function (child) {\n            if (!CoreUtils.isElementOfType(child, Column)) {\n                throw new Error(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);\n            }\n        });\n        // these are recoverable scenarios, so just print a warning.\n        if (numFrozenRows != null && numRows != null && numFrozenRows > numRows) {\n            console.warn(Errors.TABLE_NUM_FROZEN_ROWS_BOUND_WARNING);\n        }\n        if (numFrozenColumns != null && numFrozenColumns > numColumns) {\n            console.warn(Errors.TABLE_NUM_FROZEN_COLUMNS_BOUND_WARNING);\n        }\n    };\n    Table.prototype.gridDimensionsMatchProps = function () {\n        var _a = this.props, children = _a.children, numRows = _a.numRows;\n        return (this.grid != null && this.grid.numCols === React.Children.count(children) && this.grid.numRows === numRows);\n    };\n    // Hotkeys\n    // =======\n    Table.prototype.maybeRenderCopyHotkey = function () {\n        var getCellClipboardData = this.props.getCellClipboardData;\n        if (getCellClipboardData != null) {\n            return (React.createElement(Hotkey, { key: \"copy-hotkey\", label: \"Copy selected table cells\", group: \"Table\", combo: \"mod+c\", onKeyDown: this.handleCopy }));\n        }\n        else {\n            return undefined;\n        }\n    };\n    Table.prototype.maybeRenderSelectionResizeHotkeys = function () {\n        var _a = this.props, enableMultipleSelection = _a.enableMultipleSelection, selectionModes = _a.selectionModes;\n        var isSomeSelectionModeEnabled = selectionModes.length > 0;\n        if (enableMultipleSelection && isSomeSelectionModeEnabled) {\n            return [\n                React.createElement(Hotkey, { key: \"resize-selection-up\", label: \"Resize selection upward\", group: \"Table\", combo: \"shift+up\", onKeyDown: this.handleSelectionResizeUp }),\n                React.createElement(Hotkey, { key: \"resize-selection-down\", label: \"Resize selection downward\", group: \"Table\", combo: \"shift+down\", onKeyDown: this.handleSelectionResizeDown }),\n                React.createElement(Hotkey, { key: \"resize-selection-left\", label: \"Resize selection leftward\", group: \"Table\", combo: \"shift+left\", onKeyDown: this.handleSelectionResizeLeft }),\n                React.createElement(Hotkey, { key: \"resize-selection-right\", label: \"Resize selection rightward\", group: \"Table\", combo: \"shift+right\", onKeyDown: this.handleSelectionResizeRight }),\n            ];\n        }\n        else {\n            return undefined;\n        }\n    };\n    Table.prototype.maybeRenderFocusHotkeys = function () {\n        var enableFocusedCell = this.props.enableFocusedCell;\n        if (enableFocusedCell != null) {\n            return [\n                React.createElement(Hotkey, { key: \"move left\", label: \"Move focus cell left\", group: \"Table\", combo: \"left\", onKeyDown: this.handleFocusMoveLeft }),\n                React.createElement(Hotkey, { key: \"move right\", label: \"Move focus cell right\", group: \"Table\", combo: \"right\", onKeyDown: this.handleFocusMoveRight }),\n                React.createElement(Hotkey, { key: \"move up\", label: \"Move focus cell up\", group: \"Table\", combo: \"up\", onKeyDown: this.handleFocusMoveUp }),\n                React.createElement(Hotkey, { key: \"move down\", label: \"Move focus cell down\", group: \"Table\", combo: \"down\", onKeyDown: this.handleFocusMoveDown }),\n                React.createElement(Hotkey, { key: \"move tab\", label: \"Move focus cell tab\", group: \"Table\", combo: \"tab\", onKeyDown: this.handleFocusMoveRightInternal, allowInInput: true }),\n                React.createElement(Hotkey, { key: \"move shift-tab\", label: \"Move focus cell shift tab\", group: \"Table\", combo: \"shift+tab\", onKeyDown: this.handleFocusMoveLeftInternal, allowInInput: true }),\n                React.createElement(Hotkey, { key: \"move enter\", label: \"Move focus cell enter\", group: \"Table\", combo: \"enter\", onKeyDown: this.handleFocusMoveDownInternal, allowInInput: true }),\n                React.createElement(Hotkey, { key: \"move shift-enter\", label: \"Move focus cell shift enter\", group: \"Table\", combo: \"shift+enter\", onKeyDown: this.handleFocusMoveUpInternal, allowInInput: true }),\n            ];\n        }\n        else {\n            return [];\n        }\n    };\n    Table.prototype.maybeRenderSelectAllHotkey = function () {\n        if (Table_1.isSelectionModeEnabled(this.props, RegionCardinality.FULL_TABLE)) {\n            return (React.createElement(Hotkey, { key: \"select-all-hotkey\", label: \"Select all\", group: \"Table\", combo: \"mod+a\", onKeyDown: this.handleSelectAllHotkey }));\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * Replaces the selected region at the specified array index, with the\n     * region provided.\n     */\n    Table.prototype.updateSelectedRegionAtIndex = function (region, index) {\n        var _a = this.props, children = _a.children, numRows = _a.numRows;\n        var selectedRegions = this.state.selectedRegions;\n        var numColumns = React.Children.count(children);\n        var maxRowIndex = Math.max(0, numRows - 1);\n        var maxColumnIndex = Math.max(0, numColumns - 1);\n        var clampedNextRegion = Regions.clampRegion(region, maxRowIndex, maxColumnIndex);\n        var nextSelectedRegions = Regions.update(selectedRegions, clampedNextRegion, index);\n        this.handleSelection(nextSelectedRegions);\n    };\n    // Quadrant refs\n    // =============\n    Table.prototype.moveFocusCell = function (primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {\n        var selectedRegions = this.state.selectedRegions;\n        var primaryAxisPlural = primaryAxis === \"row\" ? \"rows\" : \"cols\";\n        var secondaryAxisPlural = secondaryAxis === \"row\" ? \"rows\" : \"cols\";\n        var movementDirection = isUpOrLeft ? -1 : +1;\n        var regionIntervalIndex = isUpOrLeft ? 1 : 0;\n        // try moving the cell in the direction along the primary axis\n        newFocusedCell[primaryAxis] += movementDirection;\n        var isPrimaryIndexOutOfBounds = isUpOrLeft\n            ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0]\n            : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];\n        if (isPrimaryIndexOutOfBounds) {\n            // if we moved outside the bounds of selection region,\n            // move to the start (or end) of the primary axis, and move one along the secondary\n            newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];\n            newFocusedCell[secondaryAxis] += movementDirection;\n            var isSecondaryIndexOutOfBounds = isUpOrLeft\n                ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0]\n                : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];\n            if (isSecondaryIndexOutOfBounds) {\n                // if moving along the secondary also moves us outside\n                // go to the start (or end) of the next (or previous region)\n                // (note that if there's only one region you'll be moving to the opposite corner, which is fine)\n                var newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection;\n                // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around\n                if (isUpOrLeft ? newFocusCellSelectionIndex < 0 : newFocusCellSelectionIndex >= selectedRegions.length) {\n                    newFocusCellSelectionIndex = isUpOrLeft ? selectedRegions.length - 1 : 0;\n                }\n                var newFocusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], this.grid.numRows, this.grid.numCols);\n                newFocusedCell = {\n                    col: newFocusCellRegion.cols[regionIntervalIndex],\n                    focusSelectionIndex: newFocusCellSelectionIndex,\n                    row: newFocusCellRegion.rows[regionIntervalIndex],\n                };\n            }\n        }\n        return newFocusedCell;\n    };\n    Table.prototype.shouldDisableVerticalScroll = function () {\n        var enableGhostCells = this.props.enableGhostCells;\n        var viewportRect = this.state.viewportRect;\n        var rowIndices = this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n        var isViewportUnscrolledVertically = viewportRect != null && viewportRect.top === 0;\n        var areRowHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.ROW_HEADERS);\n        var areGhostRowsVisible = enableGhostCells && this.grid.isGhostIndex(rowIndices.rowIndexEnd, 0);\n        return areGhostRowsVisible && (isViewportUnscrolledVertically || areRowHeadersLoading);\n    };\n    Table.prototype.shouldDisableHorizontalScroll = function () {\n        var enableGhostCells = this.props.enableGhostCells;\n        var viewportRect = this.state.viewportRect;\n        var columnIndices = this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);\n        var isViewportUnscrolledHorizontally = viewportRect != null && viewportRect.left === 0;\n        var areGhostColumnsVisible = enableGhostCells && this.grid.isGhostColumn(columnIndices.columnIndexEnd);\n        var areColumnHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.COLUMN_HEADERS);\n        return areGhostColumnsVisible && (isViewportUnscrolledHorizontally || areColumnHeadersLoading);\n    };\n    Table.prototype.getColumnProps = function (columnIndex) {\n        var column = this.state.childrenArray[columnIndex];\n        return column === undefined ? undefined : column.props;\n    };\n    Table.prototype.isGuidesShowing = function () {\n        return this.state.verticalGuides != null || this.state.horizontalGuides != null;\n    };\n    Table.prototype.getEnabledSelectionHandler = function (selectionMode) {\n        if (!Table_1.isSelectionModeEnabled(this.props, selectionMode)) {\n            // If the selection mode isn't enabled, return a callback that\n            // will clear the selection. For example, if row selection is\n            // disabled, clicking on the row header will clear the table's\n            // selection. If all selection modes are enabled, clicking on the\n            // same region twice will clear the selection.\n            return this.clearSelection;\n        }\n        else {\n            return this.handleSelection;\n        }\n    };\n    Table.prototype.invalidateGrid = function () {\n        this.grid = null;\n    };\n    Table.prototype.validateGrid = function () {\n        if (this.grid == null) {\n            var _a = this.props, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth;\n            var _b = this.state, rowHeights = _b.rowHeights, columnWidths = _b.columnWidths;\n            this.grid = new Grid(rowHeights, columnWidths, Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);\n            this.invokeOnVisibleCellsChangeCallback(this.state.viewportRect);\n        }\n    };\n    /**\n     * Renders a `RegionLayer`, applying styles to the regions using the\n     * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so\n     * the `IRegionStyler` should be a new instance on every render if we\n     * intend to redraw the region layer.\n     */\n    Table.prototype.maybeRenderRegions = function (getRegionStyle, quadrantType) {\n        if (this.isGuidesShowing() && !this.state.isReordering) {\n            // we want to show guides *and* the selection styles when reordering rows or columns\n            return undefined;\n        }\n        var regionGroups = Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);\n        return regionGroups.map(function (regionGroup, index) {\n            var regionStyles = regionGroup.regions.map(function (region) { return getRegionStyle(region, quadrantType); });\n            return (React.createElement(RegionLayer, { className: classNames(regionGroup.className), key: index, regions: regionGroup.regions, regionStyles: regionStyles }));\n        });\n    };\n    Table.prototype.syncViewportPosition = function (_a) {\n        var nextScrollLeft = _a.nextScrollLeft, nextScrollTop = _a.nextScrollTop;\n        var viewportRect = this.state.viewportRect;\n        if (nextScrollLeft !== undefined || nextScrollTop !== undefined) {\n            // we need to modify the scroll container explicitly for the viewport to shift. in so\n            // doing, we add the size of the header elements, which are not technically part of the\n            // \"grid\" concept (the grid only consists of body cells at present).\n            if (nextScrollTop !== undefined) {\n                var topCorrection = this.shouldDisableVerticalScroll() ? 0 : this.columnHeaderElement.clientHeight;\n                this.scrollContainerElement.scrollTop = nextScrollTop + topCorrection;\n            }\n            if (nextScrollLeft !== undefined) {\n                var leftCorrection = this.shouldDisableHorizontalScroll() || this.rowHeaderElement == null\n                    ? 0\n                    : this.rowHeaderElement.clientWidth;\n                this.scrollContainerElement.scrollLeft = nextScrollLeft + leftCorrection;\n            }\n            var nextViewportRect = new Rect(nextScrollLeft, nextScrollTop, viewportRect.width, viewportRect.height);\n            this.updateViewportRect(nextViewportRect);\n        }\n    };\n    Table.prototype.updateLocator = function () {\n        this.locator\n            .setGrid(this.grid)\n            .setNumFrozenRows(this.state.numFrozenRowsClamped)\n            .setNumFrozenColumns(this.state.numFrozenColumnsClamped);\n    };\n    Table.prototype.invokeOnVisibleCellsChangeCallback = function (viewportRect) {\n        var _a, _b;\n        var columnIndices = this.grid.getColumnIndicesInRect(viewportRect);\n        var rowIndices = this.grid.getRowIndicesInRect(viewportRect);\n        (_b = (_a = this.props).onVisibleCellsChange) === null || _b === void 0 ? void 0 : _b.call(_a, rowIndices, columnIndices);\n    };\n    /**\n     * Normalizes RenderMode.BATCH_ON_UPDATE into RenderMode.{BATCH,NONE}. We do\n     * this because there are actually multiple updates required before the\n     * <Table> is considered fully \"mounted,\" and adding that knowledge to child\n     * components would lead to tight coupling. Thus, keep it simple for them.\n     */\n    Table.prototype.getNormalizedRenderMode = function () {\n        var renderMode = this.props.renderMode;\n        var shouldBatchRender = renderMode === RenderMode.BATCH || (renderMode === RenderMode.BATCH_ON_UPDATE && this.didCompletelyMount);\n        return shouldBatchRender ? RenderMode.BATCH : RenderMode.NONE;\n    };\n    /**\n     * Returns an object with option keys mapped to their resolved values\n     * (falling back to default values as necessary).\n     */\n    Table.prototype.resolveResizeRowsByApproximateHeightOptions = function (options, rowIndex, columnIndex) {\n        var optionKeys = Object.keys(Table_1.resizeRowsByApproximateHeightDefaults);\n        var optionReducer = function (agg, key) {\n            var valueOrMapper = options === null || options === void 0 ? void 0 : options[key];\n            if (typeof valueOrMapper === \"function\") {\n                agg[key] = valueOrMapper(rowIndex, columnIndex);\n            }\n            else if (valueOrMapper != null) {\n                agg[key] = valueOrMapper;\n            }\n            else {\n                agg[key] = Table_1.resizeRowsByApproximateHeightDefaults[key];\n            }\n            return agg;\n        };\n        var resolvedOptions = optionKeys.reduce(optionReducer, {});\n        return resolvedOptions;\n    };\n    var Table_1;\n    Table.displayName = DISPLAYNAME_PREFIX + \".Table\";\n    Table.defaultProps = {\n        defaultColumnWidth: 150,\n        defaultRowHeight: 20,\n        enableFocusedCell: false,\n        enableGhostCells: false,\n        enableMultipleSelection: true,\n        enableRowHeader: true,\n        forceRerenderOnSelectionChange: false,\n        loadingOptions: [],\n        minColumnWidth: 50,\n        minRowHeight: 20,\n        numFrozenColumns: 0,\n        numFrozenRows: 0,\n        numRows: 0,\n        renderMode: RenderMode.BATCH_ON_UPDATE,\n        rowHeaderCellRenderer: renderDefaultRowHeader,\n        selectionModes: SelectionModes.ALL,\n    };\n    Table.childContextTypes = columnInteractionBarContextTypes;\n    // these default values for `resizeRowsByApproximateHeight` have been\n    // fine-tuned to work well with default Table font styles.\n    Table.resizeRowsByApproximateHeightDefaults = {\n        getApproximateCharWidth: 8,\n        getApproximateLineHeight: 18,\n        getCellHorizontalPadding: 2 * Locator.CELL_HORIZONTAL_PADDING,\n        getNumBufferLines: 1,\n    };\n    Table.SHALLOW_COMPARE_PROP_KEYS_DENYLIST = [\n        \"selectedRegions\",\n    ];\n    Table.SHALLOW_COMPARE_STATE_KEYS_DENYLIST = [\n        \"selectedRegions\",\n        \"viewportRect\",\n    ];\n    Table = Table_1 = __decorate([\n        HotkeysTarget,\n        polyfill\n    ], Table);\n    return Table;\n}(AbstractComponent2));\nexport { Table };\nfunction clampNumFrozenColumns(props) {\n    var numFrozenColumns = props.numFrozenColumns;\n    var numColumns = React.Children.count(props.children);\n    return clampPotentiallyNullValue(numFrozenColumns, numColumns);\n}\nfunction clampNumFrozenRows(props) {\n    var numFrozenRows = props.numFrozenRows, numRows = props.numRows;\n    return clampPotentiallyNullValue(numFrozenRows, numRows);\n}\n// add explicit `| null | undefined`, because the params make more sense in this\n// order, and you can't have an optional param precede a required param.\nfunction clampPotentiallyNullValue(value, max) {\n    return value == null ? 0 : Utils.clamp(value, 0, max);\n}\n//# sourceMappingURL=table.js.map"]},"metadata":{},"sourceType":"module"}